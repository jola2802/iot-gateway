[
    {
        "id": "4071c101bbc3e907",
        "type": "tab",
        "label": "Data Forwarding",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "e129ee69a298a464",
        "type": "tab",
        "label": "Image-Capture",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e7b0b0bc76ad7903",
        "type": "tab",
        "label": "Image-Upload",
        "disabled": false,
        "locked": true,
        "info": "",
        "env": []
    },
    {
        "id": "4438aad0eeb0b771",
        "type": "tab",
        "label": "testing",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "b784f457619f1095",
        "type": "subflow",
        "name": "MQTT to REST",
        "info": "This subflow collects incoming data points in an internal buffer. After a configurable time interval, the accumulated data is sent as JSON via HTTP POST to a specified REST API endpoint. Additionally, status messages are provided through the second output for process monitoring.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "URL",
                "type": "str",
                "value": "https://url.com",
                "ui": {
                    "icon": "font-awesome/fa-plug",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{\"Content-Type\":\"application/json\"}",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/opc-ua/1/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICEID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect Data & Send to REST"
        },
        "color": "#3FADB5",
        "icon": "font-awesome/fa-map-signs",
        "status": {
            "x": 460,
            "y": 20,
            "wires": [
                {
                    "id": "fb4b6772875e2106",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "2a3d9e44553dfac0",
        "type": "subflow",
        "name": "Collect & Save in File",
        "info": "This subflow aggregates data points in a buffer. After a defined time span, the collected data is saved in a configurable directory in a selected file format (JSON, XML, or CSV). The subflow sends status updates through the second output to track the progress and success of the data storage process.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "PATH",
                "type": "str",
                "value": "/data",
                "ui": {
                    "icon": "font-awesome/fa-file-text-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "json",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            },
            {
                "name": "MODE",
                "type": "str",
                "value": "new",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect & Save in File"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 480,
            "y": 20,
            "wires": [
                {
                    "id": "a101bcd063f6e0e4",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "dac356dc77e3d814",
        "type": "subflow",
        "name": "Image-Capture-Process-EXTERNAL",
        "info": "# Image Capture Process\r\n\r\nThis subflow implements a complete image capture process using OPC UA and is designed to perform all the steps required for the process in a single, consolidated flow. In detail, the subflow includes:\r\n\r\n## Connection setup and security configuration:\r\nAn OPC UA client is created that connects to an OPC UA server based on passed or environment variables (e.g. endpoint, security mode/policy, username and password).\r\n\r\n## Method call and process control:\r\nThe subflow calls a specified method on the server to initiate the image capture process. It then actively waits for a defined Boolean status (check node) to change in order to determine the right time for image processing.\r\n\r\n## Acknowledgement and optional upload:\r\nAfter successful saving, an acknowledge (Ack) is written back to the server. An HTTP POST upload of the saved file to a defined target endpoint is optional. Finally, the subflow returns a payload object with detailed information about the process, such as success message, security parameters used, storage path and the image string.\r\n\r\n## Important note:\r\nThis subflow is designed as a central component and **only needs to be implemented once in the entire Node-RED instance**. This ensures that all image acquisition processes are controlled consistently and centrally, resulting in optimized resource usage and a clear architecture.\r\n",
        "category": "Image-Capture",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "IN_ENDPOINT",
                "type": "str",
                "value": "/opc-image",
                "ui": {
                    "icon": "font-awesome/fa-chain",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#C0C0C0",
        "icon": "font-awesome/fa-exclamation",
        "status": {
            "x": 600,
            "y": 40,
            "wires": [
                {
                    "id": "7305073267fb70ed",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "a83312e9e2e175ac",
        "type": "subflow",
        "name": "Img-Cap-Process-new",
        "info": "",
        "category": "Image-Capture",
        "in": [
            {
                "x": 440,
                "y": 80,
                "wires": [
                    {
                        "id": "da0584c47df5ed3d"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 910,
                "y": 80,
                "wires": [
                    {
                        "id": "da0584c47df5ed3d",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "OPC_ENDPOINT",
                "type": "str",
                "value": "opc.tcp://192.168.0.84:48010",
                "ui": {
                    "icon": "font-awesome/fa-location-arrow",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "OPC_SEC_MODE",
                "type": "str",
                "value": "NONE",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "None"
                                },
                                "v": "NONE"
                            },
                            {
                                "l": {
                                    "de": "Sign"
                                },
                                "v": "SIGN"
                            },
                            {
                                "l": {
                                    "de": "Sign & Encrypt"
                                },
                                "v": "SIGNANDENCRYPT"
                            }
                        ]
                    }
                }
            },
            {
                "name": "OPC_SEC_POLICY",
                "type": "str",
                "value": "NONE",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "None"
                                },
                                "v": "NONE"
                            },
                            {
                                "l": {
                                    "de": "Basic128Rsa15"
                                },
                                "v": "BASIC128RSA15"
                            },
                            {
                                "l": {
                                    "de": "Basic256"
                                },
                                "v": "BASIC256"
                            },
                            {
                                "l": {
                                    "de": "Basic256Sha256"
                                },
                                "v": "BASIC256SHA256"
                            }
                        ]
                    }
                }
            },
            {
                "name": "OPC_USER",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-address-book-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "OPC_PW",
                "type": "cred",
                "ui": {
                    "icon": "font-awesome/fa-lock",
                    "type": "input",
                    "opts": {
                        "types": [
                            "cred"
                        ]
                    }
                }
            },
            {
                "name": "M_NODE_PARENT",
                "type": "str",
                "value": "ns=3;s=Demo.Method",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Method.Multiply",
                "ui": {
                    "icon": "font-awesome/fa-camera",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_ARGS",
                "type": "json",
                "value": "{\"a\":\"5\",\"b\":\"11\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "NODE_CHECK",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "icon": "font-awesome/fa-check-circle-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.ImageGIF",
                "ui": {
                    "icon": "font-awesome/fa-image",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_ACK_READ",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "BASEPATH",
                "type": "str",
                "value": "/data/images",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "99999",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "ENABLE_UPLOAD",
                "type": "str",
                "value": "true",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "true"
                                },
                                "v": "true"
                            },
                            {
                                "l": {
                                    "de": "false"
                                },
                                "v": "false"
                            }
                        ]
                    }
                }
            },
            {
                "name": "UPLOAD_URL",
                "type": "str",
                "value": "https://192.168.0.84/nodered/opc-upload",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADERS",
                "type": "json",
                "value": "{\"Content-Type\":\"application/octet-stream\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "node-red-contrib-opc-image-capture",
            "type": "opc-image-capture",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "A node to grab images from an opc-ua server.",
            "keywords": "opc-ua, gateway",
            "license": "Apache-2.0"
        },
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "image"
        ],
        "icon": "font-awesome/fa-camera-retro",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "0b0d19296544b9f8",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ef4290a715908540",
        "type": "subflow",
        "name": "InfluxDB to REST",
        "info": "",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "498350a0e7d7fa21"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "INFLUXDB",
                "type": "influxdb",
                "value": "a1403f82a270e6f4",
                "ui": {
                    "type": "conf-types"
                }
            },
            {
                "name": "URL",
                "type": "str",
                "value": "http://192.168.0.84:4999"
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{}"
            },
            {
                "name": "DEVICEID",
                "type": "str",
                "value": "1"
            },
            {
                "name": "TIMER (sec)",
                "type": "str",
                "value": "10"
            }
        ],
        "meta": {},
        "color": "#3FADB5",
        "icon": "node-red/leveldb.svg",
        "status": {
            "x": 380,
            "y": 20,
            "wires": [
                {
                    "id": "16c9290388d72e82",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "f5c5556a9e4eb0ae",
        "type": "subflow",
        "name": "Influx-to-File",
        "info": "",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "4a16a8db342b7323"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "INFLUXDB",
                "type": "influxdb",
                "value": "a1403f82a270e6f4",
                "ui": {
                    "type": "conf-types"
                }
            },
            {
                "name": "FILE_PATH",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICEID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER (sec)",
                "type": "str",
                "value": "1"
            }
        ],
        "meta": {},
        "color": "#3FADB5",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "71c0dcf56b57e3e9",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "0e108f67fce9da41",
        "type": "group",
        "z": "dac356dc77e3d814",
        "name": "OPC-Image-Capture",
        "style": {
            "fill": "#d1d1d1",
            "label": true,
            "label-position": "n",
            "color": "#000000"
        },
        "nodes": [
            "a348ffb0a5633da2",
            "f8828b8e3af04a58",
            "b96815da0497ae16",
            "842b6ef57c490524"
        ],
        "x": 314,
        "y": 119,
        "w": 312,
        "h": 282
    },
    {
        "id": "699ee5c1c3dc383e",
        "type": "group",
        "z": "e7b0b0bc76ad7903",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "cb83d0b9bbc23ce4",
            "22f3e072ed258a2f",
            "0dc25daa4866e6e4",
            "b43ada02cf576d59",
            "cf032448930f65c9"
        ],
        "x": 74,
        "y": 79,
        "w": 632,
        "h": 202
    },
    {
        "id": "4fa0c14be559bdb6",
        "type": "group",
        "z": "4438aad0eeb0b771",
        "name": "publish data to existing device",
        "style": {
            "label": true
        },
        "nodes": [
            "981c7a177fa98054",
            "6d52b6f1c958ee82",
            "5bfc5c4ac52ffcec"
        ],
        "x": 114,
        "y": 79,
        "w": 512,
        "h": 182
    },
    {
        "id": "d1d25278780d0bb3",
        "type": "global-config",
        "name": "global-config",
        "env": [
            {
                "name": "influx-token",
                "value": "secret-token",
                "type": "str"
            }
        ]
    },
    {
        "id": "e82a7202f23f3cdd",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "0b7c7515b1c6aa53",
        "type": "mqtt-broker",
        "name": "",
        "broker": "iot-gateway",
        "port": "5000",
        "tls": "e82a7202f23f3cdd",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "3",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a1403f82a270e6f4",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx-gateway",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "5007a50a62dcb950",
        "type": "s7 endpoint",
        "transport": "iso-on-tcp",
        "address": "192.168.0.84",
        "port": "1102",
        "rack": "0",
        "slot": "2",
        "localtsaphi": "01",
        "localtsaplo": "00",
        "remotetsaphi": "01",
        "remotetsaplo": "00",
        "connmode": "rack-slot",
        "adapter": "",
        "busaddr": 2,
        "cycletime": "600",
        "timeout": 2000,
        "name": "",
        "vartable": [
            {
                "addr": "I0.0",
                "name": "Input_Bool_1"
            },
            {
                "addr": "QI20",
                "name": "Output_Num_1"
            }
        ]
    },
    {
        "id": "e814f02eb2484f60",
        "type": "function",
        "z": "b784f457619f1095",
        "name": "collect & send data REST",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Versand mit Statusanzeige\n *\n * - Alle eingehenden Nachrichten werden als Datenpunkte in einem Buffer gespeichert.\n * - Nach Ablauf des konfigurierten Zeitintervalls (config.timerDelay oder msg.timerDelay) wird\n *   der Buffer per HTTP POST an den definierten Endpoint (config.endpoint oder msg.endpoint)\n *   versendet.\n * - Die HTTP-Header können ebenfalls per msg.headers überschrieben werden.\n * - Statusmeldungen werden ausschließlich über node.status() ausgegeben.\n */\n\n// Konfiguration\nvar config = {\n    topicSeparator: '/'\n};\n\n// Übernehmen der Konfiguration aus Umgebungsvariablen\nvar timerDelay = env.get(\"INTERVAL (sec)\") * 1000;\nvar endpoint   = env.get(\"URL\");\nvar headers    = env.get(\"HEADER\");\nvar topic      = env.get(\"TOPIC\");\n\n// ------------------------------\n// Hilfsfunktion zur Status-Aktualisierung (nur node.status)\n// ------------------------------\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n}\n\n// ==============================\n// Datenpunkt erfassen und in den Buffer einfügen\n// ==============================\nvar buffer = context.get('buffer') || [];\n\n// Extrahiere das letzte, nicht-leere Segment aus msg.topic als Datenpunkt-ID\nvar topicParts = msg.topic.split(config.topicSeparator).filter(function (part) {\n    return part !== '';\n});\nvar datapointId = topicParts[topicParts.length - 1];\n\n// Erstelle einen neuen Datenpunkt-Eintrag\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()  // ISO 8601 Zeitstempel\n};\n\n// Füge den Datenpunkt dem Buffer hinzu\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n\n// Status: Sammeln\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// ==============================\n// Timer-Logik: Versand des Buffers nach timerDelay, falls nicht bereits gesetzt\n// ==============================\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    setTimeout(function () {\n        // Status: Sende Daten...\n        updateStatus(\"Send Data ...\", \"yellow\", \"ring\");\n\n        // Lese den aktuell gespeicherten Buffer\n        var bufferToSend = context.get('buffer') || [];\n\n        // Erstelle den POST-Datenstring\n        var postData = JSON.stringify(bufferToSend);\n\n        // Zerlege den Endpoint in seine Bestandteile\n        var endpointUrl = url.parse(endpoint);\n        var options = {\n            hostname: endpointUrl.hostname,\n            port: endpointUrl.port,\n            path: endpointUrl.path,\n            method: 'POST',\n            headers: Object.assign({}, headers, {\n                'Content-Length': Buffer.byteLength(postData)\n            })\n        };\n\n        // Initialisiere den HTTP POST Request\n        var req = http.request(options, function (res) {\n            var responseBody = \"\";\n            res.setEncoding('utf8');\n            res.on('data', function (chunk) {\n                responseBody += chunk;\n            });\n            res.on('end', function () {\n                // node.log(\"HTTP POST response: \" + responseBody);\n                // Status: Versand abgeschlossen\n                updateStatus(\"Success Upload (\" + bufferToSend.length + \" Einträge)\", \"green\", \"dot\");\n            });\n        });\n\n        req.on('error', function (e) {\n            node.error(\"HTTP POST request error: \" + e.message);\n            updateStatus(\"Error sending data\", \"red\", \"ring\");\n        });\n\n        req.write(postData);\n        req.end();\n\n        // Buffer und Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n    }, timerDelay);\n}\n\n// Diese Funktion gibt keine reguläre Nachricht weiter.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 370,
        "y": 80,
        "wires": []
    },
    {
        "id": "b8ab04611540d0c6",
        "type": "mqtt in",
        "z": "b784f457619f1095",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "e814f02eb2484f60"
            ]
        ]
    },
    {
        "id": "fb4b6772875e2106",
        "type": "status",
        "z": "b784f457619f1095",
        "name": "",
        "scope": null,
        "x": 320,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "424f5da4789c7d8e",
        "type": "function",
        "z": "2a3d9e44553dfac0",
        "name": "collect & save in file",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Speicherung in einer Datei\n *\n * - Daten werden in einem Buffer gesammelt und nach einer bestimmten Zeit gespeichert.\n * - Speicherung in einer Datei als JSON, XML oder CSV.\n * - Möglichkeit, entweder eine Datei kontinuierlich zu erweitern oder eine neue Datei für jede Speicherung zu erstellen.\n */\n\n// -----------------------------------------------\n// 1) Subflow-Variablen aus Umgebungsvariablen\n// -----------------------------------------------\nvar config = {\n    topicSeparator: '/',\n    intervalMs: parseInt(env.get(\"INTERVAL (MS)\")) || 60000,   // Fallback: 60s\n    filePath: env.get(\"PATH\") || \"/data\",                         // Standardpfad\n    fileFormat: (env.get(\"FORMAT\") || \"json\").toLowerCase(),      // json, xml, csv\n    fileMode: (env.get(\"MODE\") || \"new\").toLowerCase(),           // \"append\" oder \"new\"\n    fileName: env.get(\"FILENAME\") || \"data\"                       // Basis-Dateiname für beide Modi\n};\n// node.log(\"Konfiguration geladen: \" + JSON.stringify(config));\n\n// -----------------------------------------------\n// 2) Hilfsfunktionen\n// -----------------------------------------------\n\n/** Aktualisiert den Node-Status (ohne Subflow-Ausgang) */\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n    // node.log(\"Status aktualisiert: \" + statusMsg);\n}\n\n/** Erzeugt den Dateiinhalt abhängig vom Format (JSON, XML oder CSV) */\nfunction buildFileContents(bufferToSave, format, existingContent = \"\") {\n    // node.log(\"Erstelle Dateiinhalt im Format \" + format + \" für \" + bufferToSave.length + \" Einträge.\");\n    switch (format) {\n        case \"xml\":\n            return buildXML(bufferToSave, existingContent);\n        case \"csv\":\n            return buildCSV(bufferToSave, existingContent);\n        case \"json\":\n        default:\n            return buildJSON(bufferToSave, existingContent);\n    }\n}\n\n/** Ermittelt die passende Dateiendung aus dem Format */\nfunction getFileExtension(format) {\n    switch (format) {\n        case \"xml\": return \"xml\";\n        case \"csv\": return \"csv\";\n        default: return \"json\";\n    }\n}\n\n/** JSON-Stringify mit optionaler Anfüge-Logik */\nfunction buildJSON(bufferToSave, existingContent) {\n    if (config.fileMode === \"append\" && existingContent) {\n        try {\n            let existingData = JSON.parse(existingContent);\n            if (Array.isArray(existingData)) {\n                existingData.push(...bufferToSave);\n            } else {\n                existingData = [...bufferToSave];\n            }\n            return JSON.stringify(existingData, null, 2);\n        } catch (err) {\n            node.error(\"JSON Parsing Error: \" + err.message);\n        }\n    }\n    return JSON.stringify(bufferToSave, null, 2);\n}\n\n/** CSV-Datei mit Header und Anfüge-Option */\nfunction buildCSV(bufferToSave, existingContent) {\n    const lines = existingContent ? existingContent.split(\"\\n\") : [\"DatapointId,Value,Timestamp\"];\n    bufferToSave.forEach(dp => {\n        // Ggf. weitere Escapes notwendig, wenn Kommas im Value\n        lines.push(`${dp.DatapointId},${dp.Value},${dp.Timestamp}`);\n    });\n    return lines.join(\"\\n\");\n}\n\n/** XML-Datei mit optionaler Anfüge-Logik */\nfunction buildXML(bufferToSave, existingContent) {\n    let xmlData = existingContent ? existingContent.replace(\"</data>\", \"\") : \"<data>\\n\";\n    bufferToSave.forEach(dp => {\n        xmlData += `  <datapoint>\\n`;\n        xmlData += `    <DatapointId>${dp.DatapointId}</DatapointId>\\n`;\n        xmlData += `    <Value>${dp.Value}</Value>\\n`;\n        xmlData += `    <Timestamp>${dp.Timestamp}</Timestamp>\\n`;\n        xmlData += `  </datapoint>\\n`;\n    });\n    xmlData += \"</data>\";\n    return xmlData;\n}\n\n// -----------------------------------------------\n// 3) Hauptlogik: Datensammlung und Timer\n// -----------------------------------------------\n\n// a) Bestehenden Buffer aus dem Context holen\nvar buffer = context.get('buffer') || [];\n// node.log(\"Buffer initialisiert. Aktueller Buffer-Inhalt: \" + JSON.stringify(buffer));\n\n// b) Datenpunkt erzeugen\nvar topicParts = msg.topic.split(config.topicSeparator).filter(part => part !== '');\nvar datapointId = topicParts[topicParts.length - 1] || \"unknown\";\n\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()\n};\n// node.log(\"Neuer Datenpunkt erzeugt: \" + JSON.stringify(datapoint));\n\n// c) In den Buffer einfügen\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n// node.log(\"Datenpunkt dem Buffer hinzugefügt. Buffer-Länge: \" + buffer.length);\n\n// d) Status aktualisieren\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// e) Timer-Logik: Daten nach config.intervalMs in Datei schreiben\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    // node.log(\"Timer gestartet für Intervall: \" + config.intervalMs + \" ms\");\n\n    setTimeout(function () {\n        // 1) Status: Speichern\n        updateStatus(\"Saving data ...\", \"yellow\", \"ring\");\n        // node.log(\"Timer ausgelöst. Starte Speicherung der Daten.\");\n\n        // 2) Buffer holen\n        var bufferToSave = context.get('buffer') || [];\n        // node.log(\"Anzahl der zu speichernden Einträge: \" + bufferToSave.length);\n\n        // 3) Dateiname & Pfad ermitteln\n        var ext = getFileExtension(config.fileFormat);\n        var fileName;\n\n        if (config.fileMode === \"append\") {\n            fileName = `${config.fileName}.${ext}`; // Feste Datei\n        } else {\n            var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            fileName = `${config.fileName}_${timestamp}.${ext}`; // Basisname + Zeitstempel\n        }\n        var fullPath = path.join(config.filePath, fileName);\n        // node.log(\"Ermittelter Dateiname: \" + fileName + \" im Verzeichnis: \" + config.filePath);\n\n        // 4) Verzeichnis erstellen, falls nicht vorhanden\n        try {\n            fs.mkdirSync(config.filePath, { recursive: true });\n            // node.log(\"Verzeichnis vorhanden oder erfolgreich erstellt: \" + config.filePath);\n        } catch (e) {\n            node.error(\"Verzeichnis konnte nicht erstellt werden: \" + e.message);\n            updateStatus(\"Dir error\", \"red\", \"ring\");\n            context.set('timerSet', false);\n            return;\n        }\n\n        // 5) Falls append-Modus, existierenden Inhalt lesen\n        let existingContent = \"\";\n        if (config.fileMode === \"append\" && fs.existsSync(fullPath)) {\n            try {\n                existingContent = fs.readFileSync(fullPath, 'utf8');\n                // node.log(\"Bestehenden Dateiinhalt erfolgreich gelesen.\");\n            } catch (err) {\n                node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n            }\n        }\n\n        // 6) Dateiinhalt erstellen\n        var fileContents = buildFileContents(bufferToSave, config.fileFormat, existingContent);\n        // node.log(\"Dateiinhalt erstellt.\");\n\n        // 7) Datei schreiben\n        fs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n            if (err) {\n                node.error(\"File write error: \" + err.message);\n                updateStatus(\"Saving error\", \"red\", \"ring\");\n            } else {\n                // node.log(\"Datei erfolgreich gespeichert: \" + fullPath);\n                updateStatus(\"Data saved (\" + bufferToSave.length + \" items)\", \"green\", \"dot\");\n            }\n        });\n\n        // 8) Buffer & Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n        // node.log(\"Buffer und Timer-Flag zurückgesetzt.\");\n\n    }, config.intervalMs);\n}\n\n// Keine reguläre Ausgabe\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 450,
        "y": 80,
        "wires": []
    },
    {
        "id": "e78f387d4ba01882",
        "type": "mqtt in",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 80,
        "wires": [
            [
                "424f5da4789c7d8e"
            ]
        ]
    },
    {
        "id": "a101bcd063f6e0e4",
        "type": "status",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "scope": null,
        "x": 360,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "a348ffb0a5633da2",
        "type": "function",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = msg.endpoint       || env.get(\"OPCUA_ENDPOINT\")       || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = msg.objectId       || env.get(\"METHOD_OBJECTID\")      || \"ns=3;s=Demo.Method\";\nconst methodId    = msg.methodId       || env.get(\"METHOD_ID\")            || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs = msg.methodArgs      || env.get(\"METHOD_ARGS\")          || \"\"\nconst checkNodeId = msg.checkNodeId    || env.get(\"CHECK_NODEID\")         || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = msg.imageNodeId    || env.get(\"IMAGE_NODEID\")         || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = msg.ackNodeId      || env.get(\"ACK_NODEID\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = msg.basePath       || env.get(\"BASE_PATH\")            || \"./data/images\";\nconst device      = msg.device         || env.get(\"DEVICE\")               || \"local-1\";\nconst enableUpload= (msg.enableUpload  || env.get(\"ENABLE_UPLOAD\")        || \"true\").toLowerCase();\nconst uploadUrl   = msg.uploadUrl      || env.get(\"UPLOAD_URL\")           || \"http://localhost:7777/opc-upload\";\nconst additionalHeaders = msg.headers  || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(msg.securityModeVar || env.get(\"OPCUA_SECURITY_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(msg.securityPolicyVar || env.get(\"OPCUA_SECURITY_POLICY\") || \"NONE\").toUpperCase();\nconst username          = msg.username || env.get(\"OPCUA_USER\") || \"\";\nconst password          = msg.password || env.get(\"OPCUA_PASSWORD\") || \"\";\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        savedFilePath = await saveImage(base64String, basePath, device);\n        node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        await writeBoolean(session, ackNodeId, true);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(savedFilePath, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            savedFilePath,\n            uploaded: (enableUpload === \"true\"),\n            image: base64String\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const inputArguments = methodArgs ? JSON.parse(methodArgs).map(arg => ({\n        dataType: opcua.DataType[arg.dataType] || opcua.DataType.String, // Standard: String\n        value: arg.value\n    })) : [];\n\n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments: []\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(filePath, url, headers = {}) {\n    const fileData = await fs.readFile(filePath);\n    const defaultHeaders = {\n        // \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...headers };\n\n    // Konfiguration für Axios anpassen, wenn HTTPS genutzt wird\n    let axiosConfig = {\n        headers: mergedHeaders,\n    };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({\n            rejectUnauthorized: false  // Deaktiviert die Prüfung selbstsignierter Zertifikate\n        });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "20",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 470,
        "y": 280,
        "wires": [
            [
                "b96815da0497ae16"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "f8828b8e3af04a58",
        "type": "http in",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "HTTP -IN- POST",
        "url": "${IN_ENDPOINT}",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 420,
        "y": 160,
        "wires": [
            [
                "842b6ef57c490524"
            ]
        ]
    },
    {
        "id": "b96815da0497ae16",
        "type": "http response",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "HTTP Response",
        "statusCode": "200",
        "headers": {},
        "x": 500,
        "y": 360,
        "wires": []
    },
    {
        "id": "842b6ef57c490524",
        "type": "function",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "Get HTTP-Daten",
        "func": "// Hole die Daten aus dem Request Body (JSON)\n// und übertrage sie in msg.* Variablen\nlet reqBody = msg.req.body || {};\n\n// Helper-Funktion zur Übermittlung von Statusmeldungen\nfunction updateStatus(statusObj) {\n    node.send([null, { _subflowStatus: statusObj }]);\n}\n\n// Beispielhafter Status zu Beginn der Verarbeitung:\nupdateStatus({ fill: \"grey\", shape: \"dot\", text: \"Mapping HTTP-Daten...\" });\n\n// Übertrage Felder aus dem Request in msg\nmsg.endpoint = reqBody.endpoint;\nmsg.objectId = reqBody.objectId;\nmsg.methodId = reqBody.methodId;\nmsg.methodArgs = reqBody.methodArguments;\nmsg.checkNodeId = reqBody.checkNodeId;\nmsg.imageNodeId = reqBody.imageNodeId;\nmsg.ackNodeId = reqBody.ackNodeId;\nmsg.basePath = reqBody.basePath;\nmsg.device = reqBody.device;\nmsg.enableUpload = reqBody.enableUpload; // \"true\"/\"false\"\nmsg.uploadUrl = reqBody.uploadUrl;\nmsg.headers = reqBody.headers;\n\n// Optional: Security / Login\nmsg.securityModeVar = reqBody.securityModeVar;\nmsg.securityPolicyVar = reqBody.securityPolicyVar;\nmsg.username = reqBody.username.String;\nmsg.password = reqBody.password.String;\n\n// Konvertiere die Security-Variablen in Strings und setze Standardwerte falls nötig\nmsg.securityModeVar = (msg.securityModeVar || \"None\").toString();\nmsg.securityPolicyVar = (msg.securityPolicyVar || \"None\").toString();\n\n// Setze Standardwerte, falls der String \"none\" (unabhängig von der Groß-/Kleinschreibung) übergeben wurde\nif (msg.securityModeVar.toLowerCase() === \"none\") {\n    msg.securityModeVar = \"None\";\n}\nif (msg.securityPolicyVar.toLowerCase() === \"none\") {\n    msg.securityPolicyVar = \"None\";\n}\n\n// Mapping der Security Modes und Policies auf OPC-UA Konstanten\nconst securityModes = {\n    \"None\": opcua.MessageSecurityMode.None,\n    \"Sign\": opcua.MessageSecurityMode.Sign,\n    \"SignAndEncrypt\": opcua.MessageSecurityMode.SignAndEncrypt\n};\n\nconst securityPolicies = {\n    \"None\": opcua.SecurityPolicy.None,\n    \"Basic128Rsa15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"Basic256\": opcua.SecurityPolicy.Basic256,\n    \"Basic256Sha256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Setze die korrekten Werte basierend auf der Eingabe\nmsg.securityModeVar = securityModes[msg.securityModeVar] || opcua.MessageSecurityMode.None;\nmsg.securityPolicyVar = securityPolicies[msg.securityPolicyVar] || opcua.SecurityPolicy.None;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            }
        ],
        "x": 470,
        "y": 220,
        "wires": [
            [
                "a348ffb0a5633da2"
            ]
        ]
    },
    {
        "id": "7305073267fb70ed",
        "type": "status",
        "z": "dac356dc77e3d814",
        "name": "",
        "scope": null,
        "x": 420,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "da0584c47df5ed3d",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = env.get(\"OPC_ENDPOINT\")         || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = env.get(\"M_NODE_PARENT\")        || \"ns=3;s=Demo.Method\";\nconst methodId    = env.get(\"M_NODE_IMAGE\")         || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs  = env.get(\"M_ARGS\")               || \"\"\nconst checkNodeId = env.get(\"NODE_CHECK\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\")           || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = env.get(\"NODE_ACK_READ\")        || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = env.get(\"BASEPATH\")             || \"./data/images\";\nconst device      = env.get(\"DEVICE_ID\")            || \"local-1\";\nconst enableUpload= env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl   = env.get(\"UPLOAD_URL\");\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        // node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        // node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        // node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        // savedFilePath = await saveImage(base64String, basePath, device);\n        // node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        // node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        // node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            // node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            // uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n    \n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // node.log(\"Using Headers: \" + JSON.stringify(mergedHeaders, null, 2));\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 670,
        "y": 80,
        "wires": [
            [
                "7a91daf2877a46a5"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "0b0d19296544b9f8",
        "type": "status",
        "z": "a83312e9e2e175ac",
        "name": "",
        "scope": null,
        "x": 80,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "18c462c840ed1a77",
        "type": "http request",
        "z": "a83312e9e2e175ac",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 870,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "7a91daf2877a46a5",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n// const fileName = filePath.split(\"/\").pop(); // Letzter Abschnitt nach dem \"/\"\n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 260,
        "wires": [
            [
                "18c462c840ed1a77"
            ]
        ]
    },
    {
        "id": "8b0261fb901db5f1",
        "type": "influxdb in",
        "z": "ef4290a715908540",
        "influxdb": "${INFLUXDB}",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 380,
        "y": 80,
        "wires": [
            [
                "92542095e6a14c91"
            ]
        ]
    },
    {
        "id": "498350a0e7d7fa21",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICEID\");\nvar timer = msg.timer || env.get(\"TIMER (sec)\"); // Erwartet einen numerischen Wert in Sekunden\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 3600; // Standard: 1 Stunde (3600 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 80,
        "wires": [
            [
                "8b0261fb901db5f1"
            ]
        ]
    },
    {
        "id": "92542095e6a14c91",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "http send",
        "func": "/**\n * Node-RED Function: Datenversand (Send) - für InfluxDB-Daten\n *\n * - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n * - Versendet diese per HTTP POST an den konfigurierten Endpoint.\n * - HTTP-Header und Endpoint können über Umgebungsvariablen (env) oder msg überschrieben werden.\n * - Aktualisiert ausschließlich den Status (node.status).\n */\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers  = env.get(\"HEADER\") || msg.headers;\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    return null;\n}\n\n// Status: Sende Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Send Data ...\" });\n\n// Erstelle den POST-Datenstring (JSON) aus msg.payload\nvar postData = JSON.stringify(msg.payload);\n\n// Zerlege den Endpoint in seine Bestandteile\nvar endpointUrl = url.parse(endpoint);\nvar options = {\n    hostname: endpointUrl.hostname,\n    port: endpointUrl.port,\n    path: endpointUrl.path,\n    method: 'POST',\n    headers: Object.assign({}, headers, {\n        'Content-Length': Buffer.byteLength(postData),\n        'Content-Type': 'application/json'\n    })\n};\n\n// Initialisiere den HTTP POST Request\nvar req = http.request(options, function (res) {\n    var responseBody = \"\";\n    res.setEncoding('utf8');\n    res.on('data', function (chunk) {\n        responseBody += chunk;\n    });\n    res.on('end', function () {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Daten versendet (\" + entryCount + \" Einträge)\" });\n    });\n});\n\nreq.on('error', function (e) {\n    node.error(\"HTTP POST request error: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Versand fehlgeschlagen\" });\n});\n\n// Sende den POST-Datenstring\nreq.write(postData);\nreq.end();\n\n// Es wird keine Nachricht weitergereicht.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            }
        ],
        "x": 540,
        "y": 80,
        "wires": []
    },
    {
        "id": "16c9290388d72e82",
        "type": "status",
        "z": "ef4290a715908540",
        "name": "",
        "scope": null,
        "x": 260,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "fa7abbee5d7c7eb7",
        "type": "influxdb in",
        "z": "f5c5556a9e4eb0ae",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 380,
        "y": 80,
        "wires": [
            [
                "a2fa737c0195922b"
            ]
        ]
    },
    {
        "id": "4a16a8db342b7323",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICEID\");\nvar timer = msg.timer || env.get(\"TIMER (sec)\"); // Erwartet einen numerischen Wert in Sekunden\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 3600; // Standard: 1 Stunde (3600 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 80,
        "wires": [
            [
                "fa7abbee5d7c7eb7"
            ]
        ]
    },
    {
        "id": "a2fa737c0195922b",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "influx-to-file",
        "func": "/**\n * Node-RED Function: Speichert die empfangenen Daten in eine Datei.\n *\n * - Unterstützt verschiedene Formate (JSON, CSV, XML).\n * - Kann entweder an eine Datei anhängen oder eine neue Datei mit Timestamp erstellen.\n * - Erstellt automatisch das Verzeichnis, falls es nicht existiert.\n * - Aktualisiert den Node-Status entsprechend.\n */\n// Konfiguration aus Umgebungsvariablen oder msg übernehmen\nvar filePath = env.get(\"FILE_PATH\") || msg.filePath || \"/data\";  // Standardverzeichnis\nvar fileName = env.get(\"FILENAME\") || msg.fileName || \"influx_data\"; // Basis-Dateiname\nvar fileMode = env.get(\"FILE_MODE\") || msg.fileMode || \"append\"; // \"append\" oder \"new\"\nvar fileFormat = (env.get(\"FILE_FORMAT\") || msg.fileFormat || \"json\").toLowerCase(); // \"json\", \"csv\", \"xml\"\n\n// Überprüfen, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu speichern\" });\n    return null;\n}\n\n// Status: Speichern der Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Speichere Daten...\" });\n\n// Funktion zur Umwandlung der Daten in das gewünschte Format\nfunction convertData(data, format, existingContent = \"\") {\n    if (format === \"json\") {\n        if (fileMode === \"append\" && existingContent) {\n            try {\n                let existingData = JSON.parse(existingContent);\n                if (Array.isArray(existingData)) {\n                    existingData.push(...data);\n                } else {\n                    existingData = [...data];\n                }\n                return JSON.stringify(existingData, null, 2);\n            } catch (err) {\n                node.error(\"JSON Parsing Error: \" + err.message);\n            }\n        }\n        return JSON.stringify(data, null, 2);\n    }\n    if (format === \"csv\") {\n        let keys = Object.keys(data[0]);\n        let csvRows = data.map(row => keys.map(k => row[k]).join(\",\"));\n        if (fileMode === \"append\" && existingContent) {\n            return existingContent + \"\\n\" + csvRows.join(\"\\n\");\n        }\n        return keys.join(\",\") + \"\\n\" + csvRows.join(\"\\n\");\n    }\n    if (format === \"xml\") {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<data>\\n';\n        data.forEach(item => {\n            xml += \"  <entry>\\n\";\n            Object.entries(item).forEach(([key, value]) => {\n                xml += `    <${key}>${value}</${key}>\\n`;\n            });\n            xml += \"  </entry>\\n\";\n        });\n        xml += \"</data>\";\n        return xml;\n    }\n    return JSON.stringify(data, null, 2); // Fallback: JSON\n}\n\n// Dateiname & Pfad ermitteln\nvar fileExtension = fileFormat === \"xml\" ? \"xml\" : fileFormat === \"csv\" ? \"csv\" : \"json\";\nvar finalFileName = fileMode === \"new\"\n    ? `${fileName}_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExtension}`\n    : `${fileName}.${fileExtension}`;\nvar fullPath = path.join(filePath, finalFileName);\n\n// Falls nötig, Verzeichnis erstellen\ntry {\n    fs.mkdirSync(filePath, { recursive: true });\n} catch (e) {\n    node.error(\"Fehler beim Erstellen des Verzeichnisses: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Verzeichnisfehler\" });\n    return null;\n}\n\n// Falls append-Modus, existierenden Inhalt lesen\nlet existingContent = \"\";\nif (fileMode === \"append\" && fs.existsSync(fullPath)) {\n    try {\n        existingContent = fs.readFileSync(fullPath, 'utf8');\n    } catch (err) {\n        node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n    }\n}\n\n// Dateiinhalt generieren\nvar fileContents = convertData(msg.payload, fileFormat, existingContent);\n\n// Datei schreiben\nfs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n    if (err) {\n        node.error(\"Fehler beim Speichern der Datei: \" + err.message);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Speichern fehlgeschlagen\" });\n    } else {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Gespeichert (\" + entryCount + \" Einträge)\" });\n    }\n});\n\n// Keine Weitergabe der Nachricht\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 550,
        "y": 80,
        "wires": []
    },
    {
        "id": "71c0dcf56b57e3e9",
        "type": "status",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "scope": null,
        "x": 60,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "ec3b319d5e4816bb",
        "type": "subflow:b784f457619f1095",
        "z": "4071c101bbc3e907",
        "name": "REST | Device 1",
        "env": [
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "30",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "INTERVAL (ms)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "MQTT_BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "str"
            },
            {
                "name": "MQTT_TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 60,
        "wires": []
    },
    {
        "id": "a9ed63b5bb3b5849",
        "type": "subflow:b784f457619f1095",
        "z": "4071c101bbc3e907",
        "name": "REST | Device 2",
        "env": [
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/2/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "INTERVAL (ms)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "MQTT_BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "str"
            },
            {
                "name": "MQTT_TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 120,
        "wires": []
    },
    {
        "id": "5c74eeaf79810b94",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "name": "Save in File CSV || Device 10",
        "env": [
            {
                "name": "PATH",
                "value": "/data/shared/files",
                "type": "str"
            },
            {
                "name": "FORMAT",
                "value": "csv",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-10",
                "type": "str"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/10/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 420,
        "y": 120,
        "wires": []
    },
    {
        "id": "fdf5d55aa5e0946d",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "name": "Save in File JSON || Device 10",
        "env": [
            {
                "name": "PATH",
                "value": "/data/shared/files",
                "type": "str"
            },
            {
                "name": "MODE",
                "value": "append",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-10",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "30",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/10/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 430,
        "y": 60,
        "wires": []
    },
    {
        "id": "6803fac32782bc06",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "Save in File XML || Device 21",
        "env": [
            {
                "name": "PATH",
                "value": "/tmp/",
                "type": "str"
            },
            {
                "name": "FORMAT",
                "value": "xml",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-21",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "5",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 420,
        "y": 180,
        "wires": []
    },
    {
        "id": "940b2b5baea63939",
        "type": "inject",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "cyclic trigger",
        "props": [],
        "repeat": "15",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 140,
        "y": 340,
        "wires": [
            [
                "1e58e260edbe452b",
                "8c3c74570e164ae4",
                "7c2c66976c1232ea"
            ]
        ]
    },
    {
        "id": "1e58e260edbe452b",
        "type": "subflow:ef4290a715908540",
        "z": "4071c101bbc3e907",
        "name": "Influx-to-REST",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "HEADER",
                "value": "{\"Content-Type\":\"application/json\"}",
                "type": "json"
            },
            {
                "name": "TIMER (sec)",
                "value": "2",
                "type": "str"
            }
        ],
        "x": 380,
        "y": 280,
        "wires": []
    },
    {
        "id": "8c3c74570e164ae4",
        "type": "subflow:f5c5556a9e4eb0ae",
        "z": "4071c101bbc3e907",
        "name": "",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "FILE_PATH",
                "value": "/data",
                "type": "str"
            },
            {
                "name": "TIMER (sec)",
                "value": "2",
                "type": "str"
            }
        ],
        "x": 370,
        "y": 340,
        "wires": []
    },
    {
        "id": "7c2c66976c1232ea",
        "type": "subflow:ef4290a715908540",
        "z": "4071c101bbc3e907",
        "name": "Influx-to-REST",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "HEADER",
                "value": "{\"Content-Type\":\"application/json\"}",
                "type": "json"
            },
            {
                "name": "DEVICEID",
                "value": "14",
                "type": "str"
            },
            {
                "name": "TIMER (sec)",
                "value": "2",
                "type": "str"
            }
        ],
        "x": 380,
        "y": 420,
        "wires": []
    },
    {
        "id": "c62365ad02fd3055",
        "type": "inject",
        "z": "e129ee69a298a464",
        "name": "Trigger",
        "props": [],
        "repeat": "15",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 120,
        "y": 60,
        "wires": [
            [
                "471967c8ff8469b0"
            ]
        ]
    },
    {
        "id": "471967c8ff8469b0",
        "type": "subflow:a83312e9e2e175ac",
        "z": "e129ee69a298a464",
        "name": "Img-Cap-Process-1",
        "env": [
            {
                "name": "OPC_ENDPOINT",
                "value": "opc.tcp://192.168.0.84:48019",
                "type": "str"
            },
            {
                "name": "OPC_SEC_MODE",
                "value": "SIGNANDENCRYPT",
                "type": "str"
            },
            {
                "name": "OPC_SEC_POLICY",
                "value": "BASIC256SHA256",
                "type": "str"
            },
            {
                "name": "OPC_PW",
                "type": "cred"
            },
            {
                "name": "BASEPATH",
                "value": "/data/shared",
                "type": "str"
            },
            {
                "name": "UPLOAD_URL",
                "value": "http://node-red:1880/opc-upload",
                "type": "str"
            }
        ],
        "x": 290,
        "y": 60,
        "wires": [
            [
                "9ec21dc807194186"
            ]
        ]
    },
    {
        "id": "f2a367057c5f98d6",
        "type": "subflow:a83312e9e2e175ac",
        "z": "e129ee69a298a464",
        "name": "Img-Cap-Process-2",
        "env": [
            {
                "name": "OPC_SEC_MODE",
                "value": "SIGN",
                "type": "str"
            },
            {
                "name": "OPC_SEC_POLICY",
                "value": "BASIC256SHA256",
                "type": "str"
            },
            {
                "name": "OPC_PW",
                "type": "cred"
            },
            {
                "name": "M_NODE_IMAGE",
                "value": "ns=3;s=Demo.Method.DoSomethingAfter10s",
                "type": "str"
            },
            {
                "name": "M_ARGS",
                "value": "{}",
                "type": "json"
            },
            {
                "name": "BASEPATH",
                "value": "/data/shared/images",
                "type": "str"
            },
            {
                "name": "DEVICE_ID",
                "value": "87878",
                "type": "str"
            }
        ],
        "x": 290,
        "y": 320,
        "wires": [
            [
                "ef2d2c093d3c50ec"
            ]
        ]
    },
    {
        "id": "6f27e5ca18fd6d52",
        "type": "inject",
        "z": "e129ee69a298a464",
        "name": "Trigger",
        "props": [],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 120,
        "y": 320,
        "wires": [
            [
                "f2a367057c5f98d6"
            ]
        ]
    },
    {
        "id": "9ec21dc807194186",
        "type": "image",
        "z": "e129ee69a298a464",
        "name": "",
        "width": 160,
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 480,
        "y": 60,
        "wires": []
    },
    {
        "id": "ef2d2c093d3c50ec",
        "type": "image",
        "z": "e129ee69a298a464",
        "name": "",
        "width": 160,
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 480,
        "y": 320,
        "wires": []
    },
    {
        "id": "cb83d0b9bbc23ce4",
        "type": "http in",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP POST /opc-upload",
        "url": "/opc-upload",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "b43ada02cf576d59"
            ]
        ]
    },
    {
        "id": "0dc25daa4866e6e4",
        "type": "http response",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP Response",
        "statusCode": "200",
        "headers": {},
        "x": 600,
        "y": 240,
        "wires": []
    },
    {
        "id": "b43ada02cf576d59",
        "type": "function",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "toBase64",
        "func": "msg.payload = msg.payload.toString(\"base64\")\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 180,
        "wires": [
            [
                "22f3e072ed258a2f"
            ]
        ]
    },
    {
        "id": "cf032448930f65c9",
        "type": "comment",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "Test Upload for debugging",
        "info": "",
        "x": 530,
        "y": 120,
        "wires": []
    },
    {
        "id": "22f3e072ed258a2f",
        "type": "image",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": true,
        "outputs": 1,
        "x": 400,
        "y": 240,
        "wires": [
            [
                "0dc25daa4866e6e4"
            ]
        ]
    },
    {
        "id": "385afc11275439a0",
        "type": "http in",
        "z": "e7b0b0bc76ad7903",
        "d": true,
        "name": "",
        "url": "/api/nodered/images",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 840,
        "wires": [
            [
                "d90419344fe2913d"
            ]
        ]
    },
    {
        "id": "d4e74fac803db0f2",
        "type": "http response",
        "z": "e7b0b0bc76ad7903",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 630,
        "y": 840,
        "wires": []
    },
    {
        "id": "d90419344fe2913d",
        "type": "function",
        "z": "e7b0b0bc76ad7903",
        "name": "get images",
        "func": "// Definiere den Pfad, aus dem alle Dateien ausgelesen werden sollen\nlet dirPath = env.get(\"BASEPATH\");\ndirPath = \"/data/shared/images/99999\";\n\n// Array, in dem die Ergebnisse gesammelt werden\nlet filesOutput = [];\n\ntry {\n    // Lese alle Dateinamen im Verzeichnis\n    let files = fs.readdirSync(dirPath);\n\n    // Iteriere über alle gefundenen Dateien\n    files.forEach(file => {\n        let filePath = path.join(dirPath, file);\n        // Prüfe, ob es sich um eine reguläre Datei handelt\n        if (fs.statSync(filePath).isFile()) {\n            // Lese den Inhalt der Datei (als UTF-8-Text; je nach Dateityp ggf. anpassen)\n            let content = fs.readFileSync(filePath, 'utf8');\n            filesOutput.push({\n                filename: file,\n                content: content\n            });\n        }\n    });\n\n    // Setze das Ergebnis in den Payload\n    msg.payload = filesOutput;\n} catch (err) {\n    // Im Fehlerfall gib die Fehlermeldung zurück\n    msg.payload = { error: err.toString() };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 450,
        "y": 840,
        "wires": [
            [
                "d4e74fac803db0f2"
            ]
        ]
    },
    {
        "id": "981c7a177fa98054",
        "type": "s7 in",
        "z": "4438aad0eeb0b771",
        "g": "4fa0c14be559bdb6",
        "endpoint": "5007a50a62dcb950",
        "mode": "single",
        "variable": "Output_Num_1",
        "diff": false,
        "name": "",
        "x": 220,
        "y": 220,
        "wires": [
            [
                "6d52b6f1c958ee82",
                "5bfc5c4ac52ffcec"
            ]
        ]
    },
    {
        "id": "6d52b6f1c958ee82",
        "type": "mqtt out",
        "z": "4438aad0eeb0b771",
        "g": "4fa0c14be559bdb6",
        "name": "",
        "topic": "data/s7/14/[223] Q20",
        "qos": "2",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0b7c7515b1c6aa53",
        "x": 500,
        "y": 220,
        "wires": []
    },
    {
        "id": "5bfc5c4ac52ffcec",
        "type": "debug",
        "z": "4438aad0eeb0b771",
        "g": "4fa0c14be559bdb6",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 430,
        "y": 120,
        "wires": []
    }
]