[
    {
        "id": "2dc52bb27159c699",
        "type": "tab",
        "label": "Data Forwarding",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8af16c2e18f5774e",
        "type": "tab",
        "label": "Image-Capture",
        "disabled": false,
        "locked": true,
        "info": "",
        "env": []
    },
    {
        "id": "f783d6a195168414",
        "type": "tab",
        "label": "Flow 1",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "b784f457619f1095",
        "type": "subflow",
        "name": "OLD - MQTT to REST",
        "info": "### **MQTT to REST Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **MQTT to REST**-Subflow sammelt kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten als JSON per HTTP POST an einen definierten REST API Endpoint versendet. Dabei gibt die Node Statusmeldungen (z. B. Buffergröße, Versandstatus) über den zweiten Ausgang zur Prozessüberwachung aus.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand ihres Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, einen **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gespeichert.\r\n\r\n2. **Zeitbasierter Versand:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (sec)`, steuert den Zeitpunkt des Datenversands.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Buffer als JSON serialisiert und per HTTP POST an den konfigurierten REST API Endpoint gesendet.\r\n\r\n3. **HTTP-Versand:**  \r\n   - Die Node erstellt aus dem Buffer den POST-Datenstring und sendet diesen unter Verwendung der konfigurierten HTTP-Header.  \r\n   - Der REST API Endpoint wird in der Umgebungsvariablen `URL` definiert.\r\n\r\n4. **Statusüberwachung:**  \r\n   - Über den zweiten Ausgang werden Statusmeldungen zur aktuellen Buffergröße und zum Versandstatus ausgegeben.\r\n\r\n#### **Beispiel für den Datenversand:**  \r\nAngenommen, der Buffer enthält zwei Datenpunkte, könnte das an den REST API Endpoint gesendete JSON-Dokument wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 22.5,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 45,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses JSON wird mittels HTTP POST an den in `URL` definierten Endpoint versendet. Die HTTP-Header, beispielsweise `{\"Content-Type\": \"application/json\"}`, werden ebenfalls mitgeschickt.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable             | Typ        | Standardwert                                              | Beschreibung |\r\n|----------------------|------------|-----------------------------------------------------------|--------------|\r\n| `URL`                | String     | `\"https://url.com\"`                                       | REST API Endpoint für den HTTP POST Versand |\r\n| `HEADER`             | JSON       | `{\"Content-Type\":\"application/json\"}`                     | HTTP-Header, die beim Versand genutzt werden |\r\n| `INTERVAL (sec)`     | Num        | `60`                                                      | Zeitintervall (in Sekunden) nach dem der Buffer versendet wird |\r\n| `BROKER`             | MQTT-Broker| -                                                         | Verknüpfung zum MQTT-Broker |\r\n| `TOPIC`              | String     | `\"data/opc-ua/1/#\"`                                        | MQTT-Topic, über das die Daten empfangen werden |\r\n| `DEVICEID`           | String     | `\"1\"`                                                     | Gerätebezeichnung, die bei der Datenaggregation berücksichtigt wird |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und Weiterleitung von MQTT-Daten an REST-basierte Anwendungen  \r\n✔ Integration in IoT-Datenpipelines zur zentralen Verarbeitung und Speicherung von Sensordaten  \r\n✔ Überwachung und Statusprotokollierung der Datenübertragung zur Fehlerdiagnose  \r\n",
        "category": "OLD",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "URL",
                "type": "str",
                "value": "https://url.com",
                "ui": {
                    "icon": "font-awesome/fa-plug",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{\"Content-Type\":\"application/json\"}",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/opc-ua/1/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect Data & Send to REST"
        },
        "color": "#3FADB5",
        "icon": "font-awesome/fa-map-signs",
        "status": {
            "x": 460,
            "y": 20,
            "wires": [
                {
                    "id": "fb4b6772875e2106",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "2a3d9e44553dfac0",
        "type": "subflow",
        "name": "OLD - MQTT to FILE",
        "info": "### **Collect & Save in File Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **Collect & Save in File**-Subflow aggregiert kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten in einem definierten Verzeichnis abgelegt. Dabei unterstützt die Node verschiedene Dateiformate (**JSON**, **CSV** oder **XML**) sowie zwei Modi: Das **Anhängen** an eine bestehende Datei oder das **Erstellen** einer neuen Datei mit Zeitstempel. Statusmeldungen zur aktuellen Buffergröße und dem Speichervorgang werden über den zweiten Ausgang ausgegeben.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand des Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, den **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gesammelt.\r\n\r\n2. **Zeitbasierte Speicherung:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (MS)`, steuert den Zeitpunkt der Speicherung.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Bufferinhalt ausgelesen und in eine Datei geschrieben.\r\n\r\n3. **Dateiformat und Schreibmodus:**  \r\n   - Das Dateiformat (JSON, CSV oder XML) wird über die Umgebungsvariable `FORMAT` festgelegt.  \r\n   - Über den Modus (`MODE`) kann festgelegt werden, ob Daten an eine bestehende Datei angehängt („append“) oder in einer neuen Datei mit Zeitstempel abgelegt werden („new“).  \r\n   - Der Basis-Dateiname wird über die Umgebungsvariable `FILENAME` definiert.\r\n\r\n4. **Verzeichnisverwaltung und Status-Updates:**  \r\n   - Das Zielverzeichnis wird (falls notwendig) automatisch erstellt.  \r\n   - Während des gesamten Prozesses werden Statusmeldungen ausgegeben, die den aktuellen Bufferinhalt sowie den Erfolg des Schreibvorgangs dokumentieren.\r\n\r\n#### **Beispiel für einen gespeicherten Dateiinhalt (im JSON-Format):**  \r\nAngenommen, der Buffer enthält drei Datenpunkte, könnte der Inhalt der gespeicherten Datei wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 21.7,\r\n    \"Timestamp\": \"2023-03-01T10:15:30.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 48,\r\n    \"Timestamp\": \"2023-03-01T10:15:35.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"pressure\",\r\n    \"Value\": 1013,\r\n    \"Timestamp\": \"2023-03-01T10:15:40.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses Beispiel zeigt, wie die Datenpunkte im JSON-Format strukturiert werden. Ähnliche Beispiele können für CSV oder XML erzeugt werden, wobei CSV z. B. wie folgt aussehen könnte:\r\n\r\n```\r\nDatapointId,Value,Timestamp\r\ntemperature,21.7,2023-03-01T10:15:30.000Z\r\nhumidity,48,2023-03-01T10:15:35.000Z\r\npressure,1013,2023-03-01T10:15:40.000Z\r\n```\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable           | Typ            | Standardwert           | Beschreibung                                                   |\r\n|--------------------|----------------|------------------------|----------------------------------------------------------------|\r\n| `PATH`             | String         | `/data`                | Verzeichnis, in dem die Datei gespeichert wird                 |\r\n| `FORMAT`           | String         | `json`                 | Dateiformat: JSON, CSV oder XML                                |\r\n| `MODE`             | String         | `new`                  | Schreibmodus: „append“ oder „new“                              |\r\n| `FILENAME`         | String         | (leer)                 | Basis-Dateiname für die Speicherung                          |\r\n| `INTERVAL (sec)`   | Num            | `60`                   | Speichervorgang-Intervall in Sekunden (wird zur Anzeige genutzt)|\r\n| `INTERVAL (MS)`    | Num            | `60000`                | Speichervorgang-Intervall in Millisekunden                     |\r\n| `BROKER`           | MQTT-Broker    | -                      | Verknüpfung zum MQTT-Broker                                    |\r\n| `TOPIC`            | String         | `data/#`               | MQTT-Topic, über das Daten empfangen werden                    |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und persistente Speicherung von Zeitreihendaten aus MQTT-Streams  \r\n✔ Erstellung von Datenexporten für spätere Analysen oder externe Systeme  \r\n✔ Flexible Speicherung in verschiedenen Formaten und Modi (Anhängen oder neu erstellen)  \r\n",
        "category": "OLD",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "PATH",
                "type": "str",
                "value": "/data",
                "ui": {
                    "icon": "font-awesome/fa-file-text-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "json",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            },
            {
                "name": "MODE",
                "type": "str",
                "value": "new",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect & Save in File"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 480,
            "y": 20,
            "wires": [
                {
                    "id": "a101bcd063f6e0e4",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "dac356dc77e3d814",
        "type": "subflow",
        "name": "Image-Capture-in-Node-RED",
        "info": "# Image Capture Process\r\n\r\nThis subflow implements a complete image capture process using OPC UA and is designed to perform all the steps required for the process in a single, consolidated flow. In detail, the subflow includes:\r\n\r\n## Connection setup and security configuration:\r\nAn OPC UA client is created that connects to an OPC UA server based on passed or environment variables (e.g. endpoint, security mode/policy, username and password).\r\n\r\n## Method call and process control:\r\nThe subflow calls a specified method on the server to initiate the image capture process. It then actively waits for a defined Boolean status (check node) to change in order to determine the right time for image processing.\r\n\r\n## Acknowledgement and optional upload:\r\nAfter successful saving, an acknowledge (Ack) is written back to the server. An HTTP POST upload of the saved file to a defined target endpoint is optional. Finally, the subflow returns a payload object with detailed information about the process, such as success message, security parameters used, storage path and the image string.\r\n\r\n## Important note:\r\nThis subflow is designed as a central component and **only needs to be implemented once in the entire Node-RED instance**. This ensures that all image acquisition processes are controlled consistently and centrally, resulting in optimized resource usage and a clear architecture.\r\n",
        "category": "OLD",
        "in": [
            {
                "x": 220,
                "y": 200,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 700,
                "y": 200,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "IN_ENDPOINT",
                "type": "str",
                "value": "/opc-image",
                "ui": {
                    "icon": "font-awesome/fa-chain",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "OPC_ENDPOINT",
                "type": "str",
                "value": "opc.tcp://xx:48010",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "num",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "M_NODE_PARENT",
                "type": "str",
                "value": "ns=3;s=Demo.Methods",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Methods.Multiply",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_ARGS",
                "type": "json",
                "value": "{\"a\":\"1\",\"b\":\"1\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "NODE_CHECK",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.ImageGIF",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_ACK_READ",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "ENABLE_UPLOAD",
                "type": "str",
                "value": "false",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "true"
                                },
                                "v": "true"
                            },
                            {
                                "l": {
                                    "de": "false"
                                },
                                "v": "false"
                            }
                        ]
                    }
                }
            },
            {
                "name": "UPLOAD_URL",
                "type": "str",
                "value": "https://demo/demo",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "TIMESTAMP_HEADER_NAME",
                "type": "str",
                "value": "BLOB_TIMESTAMP",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADERS",
                "type": "json",
                "value": "{\"BLOB_TIME\":\"\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "image-base64-string"
        ],
        "icon": "font-awesome/fa-exclamation",
        "status": {
            "x": 600,
            "y": 40,
            "wires": [
                {
                    "id": "7305073267fb70ed",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ef4290a715908540",
        "type": "subflow",
        "name": "InfluxDB to REST",
        "info": "### **Beschreibung**  \r\nDer **InfluxDB to REST** Subflow ermöglicht den periodischen Abruf von Sensordaten aus einer InfluxDB-Datenbank und deren anschließende Übertragung per HTTP POST an einen definierten REST-API-Endpunkt. Die Node ist speziell für IoT-Datenpipelines konzipiert und erlaubt eine flexible Konfiguration der Ziel-URL, HTTP-Header und Abfrageintervalle. Dadurch können Daten aus InfluxDB nahtlos in Cloud- oder Edge-Anwendungen integriert werden.\r\n\r\n### **Funktionsweise**  \r\n1. **Abfrageerstellung:**  \r\n   - Generierung einer Flux-Query, die Daten aus einem dynamisch konfigurierten Zeitintervall (`TIMER`) abfragt.  \r\n   - Filterung der Daten anhand der `DEVICE_ID`, um gerätespezifische Informationen zu extrahieren.\r\n2. **Datenabruf:**  \r\n   - Die erstellte Flux-Query wird an die InfluxDB gesendet und die ermittelten Daten werden als JSON-Objekt abgerufen.\r\n3. **Datenversand:**  \r\n   - Die abgerufenen Daten werden per HTTP POST an den in der Umgebungsvariable `URL` konfigurierten REST-API-Endpunkt übermittelt.  \r\n   - HTTP-Header können über die Umgebungsvariable `HEADER` angepasst werden.\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusinformationen, wie die Laufzeit der Abfrage und die Anzahl der übertragenen Datensätze, visuell dargestellt.\r\n\r\n### **Konfigurierbare Umgebungsvariablen**  \r\n\r\n| Variable       | Typ       | Standardwert                          | Beschreibung                                                  |\r\n|----------------|-----------|---------------------------------------|---------------------------------------------------------------|\r\n| `DEVICE_ID`    | String    | `1`                                   | ID des Geräts, dessen Daten abgefragt werden                  |\r\n| `TIMER`        | String    | `10`                                  | Zeitintervall für die Datenabfrage in Sekunden                |\r\n| `URL`          | String    | `\"http://url.com\"`           | Ziel-URL für den HTTP-POST-Request                            |\r\n| `HEADER`       | JSON      | `{}`                                  | Zusätzliche HTTP-Header (im JSON-Format)                      |\r\n\r\n### **Einsatzmöglichkeiten**  \r\n- **Automatische Datenübertragung:** Integration von Sensordaten aus InfluxDB in REST-basierte Systeme.  \r\n- **IoT-Datenpipelines:** Unterstützung von Echtzeit-Datenströmen in Cloud- und Edge-Anwendungen.  \r\n- **Datensynchronisation:** Regelmäßige Synchronisation von InfluxDB-Daten mit externen Datenplattformen.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "DEVICE_ID",
                "type": "num",
                "value": "1",
                "ui": {
                    "icon": "font-awesome/fa-microchip",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER",
                "type": "num",
                "value": "10",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "URL",
                "type": "str",
                "value": "http://192.168.0.84:4999",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{}",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "idpm-rest",
            "type": "idpm-rest",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "-",
            "keywords": "idpm, rest"
        },
        "color": "#3FADB5",
        "icon": "node-red/leveldb.svg",
        "status": {
            "x": 380,
            "y": 20,
            "wires": [
                {
                    "id": "16c9290388d72e82",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "f5c5556a9e4eb0ae",
        "type": "subflow",
        "name": "InfluxDB to FILE",
        "info": "### **Beschreibung**  \r\nDer **Influx to FILE**-Subflow ermöglicht das periodische Abrufen von Daten aus einer InfluxDB-Datenbank und deren Speicherung in einer lokalen Datei. Die Daten können in verschiedenen Formaten abgelegt werden, nämlich **JSON**, **CSV** oder **XML**. Dabei stehen flexible Konfigurationsoptionen zur Verfügung: Neben dem Ausgabemodus (Anhängen an bestehende Dateien oder Erstellen einer neuen Datei mit Zeitstempel) können auch Zielverzeichnis und Dateiname optional angegeben werden.\r\n\r\n### **Funktionsweise**  \r\n1. **Abfrageerstellung:**  \r\n   - Der Subflow generiert eine Flux-Query, um die letzten *n* Sekunden aus der InfluxDB abzufragen.  \r\n   - Der abzufragende Zeitraum wird über die Umgebungsvariable `TIMER` konfiguriert.  \r\n   - Die Query filtert die Daten anhand der `DEVICE_ID`, um gerätespezifische Informationen zu extrahieren.\r\n\r\n2. **Datenabruf:**  \r\n   - Die erstellte Flux-Query wird an die InfluxDB gesendet, und die abgerufenen Daten werden als JSON-Objekt weitergereicht.\r\n\r\n3. **Dateispeicherung:**  \r\n   - Die Daten werden im definierten Verzeichnis abgelegt, wobie ein konkreter Zielordner **optional** über `FOLDER` definiert werden kann.  \r\n   - Der Dateiname kann **optional** über `FILENAME` angegeben werden; fehlt dieser, wird ein Standardname samt Timestamp generiert.  \r\n   - Der Ausgabemodus wird über `FILE_MODE` bestimmt, wobei zwischen dem Anhängen an eine bestehende Datei (`append`) und dem Erstellen einer neuen Datei (`new`) gewählt werden kann.\r\n   - Über die Umgebungsvariable `FORMAT` kann das Ausgabeformat gewählt werden: **json**, **csv** oder **xml**.  \r\n\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusmeldungen zur Laufzeitdauer und zur Anzahl der gespeicherten Datensätze ausgegeben.\r\n\r\n### **Konfigurierbare Umgebungsvariablen**\r\n\r\n| Variable       | Typ       | Standardwert | Beschreibung                                                  |\r\n|----------------|-----------|--------------|---------------------------------------------------------------|\r\n| `DEVICE_ID`    | Number    | `1`          | ID des Geräts, dessen Daten abgefragt werden                  |\r\n| `TIMER`  | Number    | `30`          | Zeitintervall für die Datenabfrage (in Sekunden)              |\r\n| `FOLDER`       | String    | -            | Optionaler Zielordner nach `/data/shared/`-Pfad |\r\n| `FILENAME`     | String    | -            | Optionaler Dateiname; wird bei Fehlen automatisch generiert   |\r\n| `FILE_MODE`    | String    | `append`     | Dateiausgabe-Modus: `append` (Anhängen) oder `new` (Neue Datei erstellen) |\r\n| `FORMAT`       | String    | `csv`        | Ausgabeformat: **csv**, **json** oder **xml**                   |\r\n\r\n### **Einsatzmöglichkeiten**  \r\n- **Speicherung von Zeitreihenmesswerten:** Archivierung von Sensordaten aus der InfluxDB in einem strukturierten Dateiformat.  \r\n- **Datenexport:** Erstellung von Exportdateien für externe Systeme oder weiterführende Analysen.  \r\n- **Regelmäßige Datensicherung:** Automatisierte Backups und Datenexporte zur kontinuierlichen Sicherung oder Auswertung von Zeitreihendaten.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "DEVICE_ID",
                "type": "num",
                "value": "1",
                "ui": {
                    "icon": "font-awesome/fa-microchip",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER",
                "type": "num",
                "value": "30",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "FOLDER",
                "type": "str",
                "value": "files",
                "ui": {
                    "icon": "font-awesome/fa-folder-open",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-file-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FILE_MODE",
                "type": "str",
                "value": "append",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "csv",
                "ui": {
                    "icon": "font-awesome/fa-file-archive-o",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "idpm-file",
            "type": "idpm-file",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "-",
            "keywords": "ipdm, file"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "71c0dcf56b57e3e9",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "acb6954d7bc4254f",
        "type": "subflow",
        "name": "Image-Capture-API",
        "info": "",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [
            {
                "x": 520,
                "y": 120,
                "wires": [
                    {
                        "id": "4a78acdb944cb3d8",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#C0C0C0",
        "status": {
            "x": 660,
            "y": 40,
            "wires": [
                {
                    "id": "061e48c71685d276",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "10d72cae5a6340f6",
        "type": "subflow",
        "name": "MQTT to REST",
        "info": "### **MQTT to REST Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **MQTT to REST**-Subflow sammelt kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten als JSON per HTTP POST an einen definierten REST API Endpoint versendet. Dabei gibt die Node Statusmeldungen (z. B. Buffergröße, Versandstatus) über den zweiten Ausgang zur Prozessüberwachung aus.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand ihres Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, einen **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gespeichert.\r\n\r\n2. **Zeitbasierter Versand:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (sec)`, steuert den Zeitpunkt des Datenversands.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Buffer als JSON serialisiert und per HTTP POST an den konfigurierten REST API Endpoint gesendet.\r\n\r\n3. **HTTP-Versand:**  \r\n   - Die Node erstellt aus dem Buffer den POST-Datenstring und sendet diesen unter Verwendung der konfigurierten HTTP-Header.  \r\n   - Der REST API Endpoint wird in der Umgebungsvariablen `URL` definiert.\r\n\r\n4. **Statusüberwachung:**  \r\n   - Über den zweiten Ausgang werden Statusmeldungen zur aktuellen Buffergröße und zum Versandstatus ausgegeben.\r\n\r\n#### **Beispiel für den Datenversand:**  \r\nAngenommen, der Buffer enthält zwei Datenpunkte, könnte das an den REST API Endpoint gesendete JSON-Dokument wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 22.5,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 45,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses JSON wird mittels HTTP POST an den in `URL` definierten Endpoint versendet. Die HTTP-Header, beispielsweise `{\"Content-Type\": \"application/json\"}`, werden ebenfalls mitgeschickt.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable             | Typ        | Standardwert                                              | Beschreibung |\r\n|----------------------|------------|-----------------------------------------------------------|--------------|\r\n| `URL`                | String     | `\"https://url.com\"`                                       | REST API Endpoint für den HTTP POST Versand |\r\n| `HEADER`             | JSON       | `{\"Content-Type\":\"application/json\"}`                     | HTTP-Header, die beim Versand genutzt werden |\r\n| `INTERVAL (sec)`     | Num        | `60`                                                      | Zeitintervall (in Sekunden) nach dem der Buffer versendet wird |\r\n| `BROKER`             | MQTT-Broker| -                                                         | Verknüpfung zum MQTT-Broker |\r\n| `TOPIC`              | String     | `\"data/opc-ua/1/#\"`                                        | MQTT-Topic, über das die Daten empfangen werden |\r\n| `DEVICEID`           | String     | `\"1\"`                                                     | Gerätebezeichnung, die bei der Datenaggregation berücksichtigt wird |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und Weiterleitung von MQTT-Daten an REST-basierte Anwendungen  \r\n✔ Integration in IoT-Datenpipelines zur zentralen Verarbeitung und Speicherung von Sensordaten  \r\n✔ Überwachung und Statusprotokollierung der Datenübertragung zur Fehlerdiagnose  \r\n",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "URL",
                "type": "str",
                "value": "https://url.com",
                "ui": {
                    "icon": "font-awesome/fa-plug",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{\"Content-Type\":\"application/json\"}",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/opc-ua/1/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect Data & Send to REST"
        },
        "color": "#3FADB5",
        "icon": "font-awesome/fa-map-signs",
        "status": {
            "x": 460,
            "y": 20,
            "wires": [
                {
                    "id": "05d51a8734299975",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "57f1078111053a5e",
        "type": "subflow",
        "name": "Img-Cap + Preprocess",
        "info": "",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [
            {
                "x": 930,
                "y": 100,
                "wires": [
                    {
                        "id": "628e797cd0d0b7af",
                        "port": 0
                    }
                ]
            },
            {
                "x": 930,
                "y": 340,
                "wires": [
                    {
                        "id": "6cc5d6df139f44bc",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#C0C0C0",
        "outputLabels": [
            "Raw-Image",
            "Processed-Image"
        ],
        "status": {
            "x": 220,
            "y": 40,
            "wires": [
                {
                    "id": "2b6eb93382b47bd0",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "78414965a2b1d621",
        "type": "group",
        "z": "ef4290a715908540",
        "name": "BMK",
        "style": {
            "label": true
        },
        "nodes": [
            "909cfd3350ca8386",
            "0e226ce77eeb9e38",
            "dff4cd78f67f45a4",
            "2f2bbe367a92dd21",
            "0d0927f611cb7ec5"
        ],
        "x": 184,
        "y": 499,
        "w": 762,
        "h": 182
    },
    {
        "id": "3fe1ed64fcf761ad",
        "type": "group",
        "z": "acb6954d7bc4254f",
        "name": "BMK Implementierung",
        "style": {
            "label": true
        },
        "nodes": [
            "445e86533b09c2a0",
            "4a78acdb944cb3d8",
            "55b87dd8a941aea8",
            "d662cc824562b25b",
            "fd15d59808abbc1e",
            "2bf0ffb2de7e1870"
        ],
        "x": 14,
        "y": 179,
        "w": 998,
        "h": 468
    },
    {
        "id": "fd15d59808abbc1e",
        "type": "group",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "Bild an Backend schicken",
        "style": {
            "label": true
        },
        "nodes": [
            "ddce54b01f874280",
            "b9a7313e92123d8d"
        ],
        "x": 534,
        "y": 279,
        "w": 452,
        "h": 82
    },
    {
        "id": "2bf0ffb2de7e1870",
        "type": "group",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "Bild weiterleiten: REST oder Lokal Speichern",
        "style": {
            "label": true
        },
        "nodes": [
            "3502dba94720d721",
            "b8081502c40f9291",
            "289ee7041572313b",
            "3292cba161de8b89",
            "2c5e65cc7b5c67c6",
            "cba1a0b3d2a37ad4",
            "1ccd8789af4f86fd",
            "2718793c3a462335"
        ],
        "x": 94,
        "y": 379,
        "w": 892,
        "h": 242
    },
    {
        "id": "d1d25278780d0bb3",
        "type": "global-config",
        "env": [
            {
                "name": "influx-token",
                "value": "secret-token",
                "type": "str"
            }
        ]
    },
    {
        "id": "e82a7202f23f3cdd",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "0b7c7515b1c6aa53",
        "type": "mqtt-broker",
        "name": "",
        "broker": "iot-gateway",
        "port": "${MQTT_LISTENER_LOCAL_TCP_ADDRESS}",
        "tls": "e82a7202f23f3cdd",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "3",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a1403f82a270e6f4",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx-gateway",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "${INFLUXDB_URL}",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "10c6821e0eaf4a53",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://172.16.224.108:4840/UA/VSE/Server",
        "secpol": "None",
        "secmode": "None",
        "none": true,
        "login": false,
        "usercert": false,
        "usercertificate": "",
        "userprivatekey": ""
    },
    {
        "id": "8987f6d2fded3156",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx-gateway",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "${INFLUXDB_URL}",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "e814f02eb2484f60",
        "type": "function",
        "z": "b784f457619f1095",
        "name": "collect & send data REST",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Versand mit Statusanzeige\n *\n * - Alle eingehenden Nachrichten werden als Datenpunkte in einem Buffer gespeichert.\n * - Nach Ablauf des konfigurierten Zeitintervalls (config.timerDelay oder msg.timerDelay) wird\n *   der Buffer per HTTP POST an den definierten Endpoint (config.endpoint oder msg.endpoint)\n *   versendet.\n * - Die HTTP-Header können ebenfalls per msg.headers überschrieben werden.\n * - Statusmeldungen werden ausschließlich über node.status() ausgegeben.\n */\n\n// Konfiguration\nvar config = {\n    topicSeparator: '/'\n};\n\n// Übernehmen der Konfiguration aus Umgebungsvariablen\nvar timerDelay = env.get(\"INTERVAL (sec)\") * 1000;\nvar endpoint   = env.get(\"URL\");\nvar headers    = env.get(\"HEADER\");\nvar topic      = env.get(\"TOPIC\");\n\n// ------------------------------\n// Hilfsfunktion zur Status-Aktualisierung (nur node.status)\n// ------------------------------\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n}\n\n// ==============================\n// Datenpunkt erfassen und in den Buffer einfügen\n// ==============================\nvar buffer = context.get('buffer') || [];\n\n// Extrahiere das letzte, nicht-leere Segment aus msg.topic als Datenpunkt-ID\nvar topicParts = msg.topic.split(config.topicSeparator).filter(function (part) {\n    return part !== '';\n});\nvar datapointId = topicParts[topicParts.length - 1];\n\n// Erstelle einen neuen Datenpunkt-Eintrag\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()  // ISO 8601 Zeitstempel\n};\n\n// Füge den Datenpunkt dem Buffer hinzu\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n\n// Status: Sammeln\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// ==============================\n// Timer-Logik: Versand des Buffers nach timerDelay, falls nicht bereits gesetzt\n// ==============================\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    setTimeout(function () {\n        // Status: Sende Daten...\n        updateStatus(\"Send Data ...\", \"yellow\", \"ring\");\n\n        // Lese den aktuell gespeicherten Buffer\n        var bufferToSend = context.get('buffer') || [];\n\n        // Erstelle den POST-Datenstring\n        var postData = JSON.stringify(bufferToSend);\n\n        // Zerlege den Endpoint in seine Bestandteile\n        var endpointUrl = url.parse(endpoint);\n        var options = {\n            hostname: endpointUrl.hostname,\n            port: endpointUrl.port,\n            path: endpointUrl.path,\n            method: 'POST',\n            headers: Object.assign({}, headers, {\n                'Content-Length': Buffer.byteLength(postData)\n            })\n        };\n\n        // Initialisiere den HTTP POST Request\n        var req = http.request(options, function (res) {\n            var responseBody = \"\";\n            res.setEncoding('utf8');\n            res.on('data', function (chunk) {\n                responseBody += chunk;\n            });\n            res.on('end', function () {\n                // node.log(\"HTTP POST response: \" + responseBody);\n                // Status: Versand abgeschlossen\n                updateStatus(\"Success Upload (\" + bufferToSend.length + \" Einträge)\", \"green\", \"dot\");\n            });\n        });\n\n        req.on('error', function (e) {\n            node.error(\"HTTP POST request error: \" + e.message);\n            updateStatus(\"Error sending data\", \"red\", \"ring\");\n        });\n\n        req.write(postData);\n        req.end();\n\n        // Buffer und Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n    }, timerDelay);\n}\n\n// Diese Funktion gibt keine reguläre Nachricht weiter.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 370,
        "y": 80,
        "wires": []
    },
    {
        "id": "b8ab04611540d0c6",
        "type": "mqtt in",
        "z": "b784f457619f1095",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "e814f02eb2484f60"
            ]
        ]
    },
    {
        "id": "fb4b6772875e2106",
        "type": "status",
        "z": "b784f457619f1095",
        "name": "",
        "scope": null,
        "x": 320,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "424f5da4789c7d8e",
        "type": "function",
        "z": "2a3d9e44553dfac0",
        "name": "collect & save in file",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Speicherung in einer Datei\n *\n * - Daten werden in einem Buffer gesammelt und nach einer bestimmten Zeit gespeichert.\n * - Speicherung in einer Datei als JSON, XML oder CSV.\n * - Möglichkeit, entweder eine Datei kontinuierlich zu erweitern oder eine neue Datei für jede Speicherung zu erstellen.\n */\n\n// -----------------------------------------------\n// 1) Subflow-Variablen aus Umgebungsvariablen\n// -----------------------------------------------\nvar config = {\n    topicSeparator: '/',\n    intervalMs: parseInt(env.get(\"INTERVAL (MS)\")) || 60000,   // Fallback: 60s\n    filePath: env.get(\"PATH\") || \"/data\",                         // Standardpfad\n    fileFormat: (env.get(\"FORMAT\") || \"json\").toLowerCase(),      // json, xml, csv\n    fileMode: (env.get(\"MODE\") || \"new\").toLowerCase(),           // \"append\" oder \"new\"\n    fileName: env.get(\"FILENAME\") || \"data\"                       // Basis-Dateiname für beide Modi\n};\n// node.log(\"Konfiguration geladen: \" + JSON.stringify(config));\n\n// -----------------------------------------------\n// 2) Hilfsfunktionen\n// -----------------------------------------------\n\nfunction formatTimestamp(date) {\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n/** Aktualisiert den Node-Status (ohne Subflow-Ausgang) */\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n    // node.log(\"Status aktualisiert: \" + statusMsg);\n}\n\n/** Erzeugt den Dateiinhalt abhängig vom Format (JSON, XML oder CSV) */\nfunction buildFileContents(bufferToSave, format, existingContent = \"\") {\n    // node.log(\"Erstelle Dateiinhalt im Format \" + format + \" für \" + bufferToSave.length + \" Einträge.\");\n    switch (format) {\n        case \"xml\":\n            return buildXML(bufferToSave, existingContent);\n        case \"csv\":\n            return buildCSV(bufferToSave, existingContent);\n        case \"json\":\n        default:\n            return buildJSON(bufferToSave, existingContent);\n    }\n}\n\n/** Ermittelt die passende Dateiendung aus dem Format */\nfunction getFileExtension(format) {\n    switch (format) {\n        case \"xml\": return \"xml\";\n        case \"csv\": return \"csv\";\n        default: return \"json\";\n    }\n}\n\n/** JSON-Stringify mit optionaler Anfüge-Logik */\nfunction buildJSON(bufferToSave, existingContent) {\n    if (config.fileMode === \"append\" && existingContent) {\n        try {\n            let existingData = JSON.parse(existingContent);\n            if (Array.isArray(existingData)) {\n                existingData.push(...bufferToSave);\n            } else {\n                existingData = [...bufferToSave];\n            }\n            return JSON.stringify(existingData, null, 2);\n        } catch (err) {\n            node.error(\"JSON Parsing Error: \" + err.message);\n        }\n    }\n    return JSON.stringify(bufferToSave, null, 2);\n}\n\n/** CSV-Datei mit Header und Anfüge-Option */\nfunction buildCSV(bufferToSave, existingContent) {\n    const lines = existingContent ? existingContent.split(\"\\n\") : [\"DatapointId,Value,Timestamp\"];\n    bufferToSave.forEach(dp => {\n        // Ggf. weitere Escapes notwendig, wenn Kommas im Value\n        lines.push(`${dp.DatapointId},${dp.Value},${dp.Timestamp}`);\n    });\n    return lines.join(\"\\n\");\n}\n\n/** XML-Datei mit optionaler Anfüge-Logik */\nfunction buildXML(bufferToSave, existingContent) {\n    let xmlData = existingContent ? existingContent.replace(\"</data>\", \"\") : \"<data>\\n\";\n    bufferToSave.forEach(dp => {\n        xmlData += `  <datapoint>\\n`;\n        xmlData += `    <DatapointId>${dp.DatapointId}</DatapointId>\\n`;\n        xmlData += `    <Value>${dp.Value}</Value>\\n`;\n        xmlData += `    <Timestamp>${dp.Timestamp}</Timestamp>\\n`;\n        xmlData += `  </datapoint>\\n`;\n    });\n    xmlData += \"</data>\";\n    return xmlData;\n}\n\n// -----------------------------------------------\n// 3) Hauptlogik: Datensammlung und Timer\n// -----------------------------------------------\n\n// a) Bestehenden Buffer aus dem Context holen\nvar buffer = context.get('buffer') || [];\n// node.log(\"Buffer initialisiert. Aktueller Buffer-Inhalt: \" + JSON.stringify(buffer));\n\n// b) Datenpunkt erzeugen\nvar topicParts = msg.topic.split(config.topicSeparator).filter(part => part !== '');\nvar datapointId = topicParts[topicParts.length - 1] || \"unknown\";\n\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()\n};\n// node.log(\"Neuer Datenpunkt erzeugt: \" + JSON.stringify(datapoint));\n\n// c) In den Buffer einfügen\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n// node.log(\"Datenpunkt dem Buffer hinzugefügt. Buffer-Länge: \" + buffer.length);\n\n// d) Status aktualisieren\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// e) Timer-Logik: Daten nach config.intervalMs in Datei schreiben\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    // node.log(\"Timer gestartet für Intervall: \" + config.intervalMs + \" ms\");\n\n    setTimeout(function () {\n        // 1) Status: Speichern\n        updateStatus(\"Saving data ...\", \"yellow\", \"ring\");\n        // node.log(\"Timer ausgelöst. Starte Speicherung der Daten.\");\n\n        // 2) Buffer holen\n        var bufferToSave = context.get('buffer') || [];\n        // node.log(\"Anzahl der zu speichernden Einträge: \" + bufferToSave.length);\n\n        // 3) Dateiname & Pfad ermitteln\n        var ext = getFileExtension(config.fileFormat);\n        var fileName;\n\n        if (config.fileMode === \"append\") {\n            fileName = `${config.fileName}.${ext}`; // Feste Datei\n        } else {\n            var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            fileName = `${config.fileName}_${timestamp}.${ext}`; // Basisname + Zeitstempel\n        }\n        var fullPath = path.join(config.filePath, fileName);\n        // node.log(\"Ermittelter Dateiname: \" + fileName + \" im Verzeichnis: \" + config.filePath);\n\n        // 4) Verzeichnis erstellen, falls nicht vorhanden\n        try {\n            fs.mkdirSync(config.filePath, { recursive: true });\n            // node.log(\"Verzeichnis vorhanden oder erfolgreich erstellt: \" + config.filePath);\n        } catch (e) {\n            node.error(\"Verzeichnis konnte nicht erstellt werden: \" + e.message);\n            updateStatus(\"Dir error\", \"red\", \"ring\");\n            context.set('timerSet', false);\n            return;\n        }\n\n        // 5) Falls append-Modus, existierenden Inhalt lesen\n        let existingContent = \"\";\n        if (config.fileMode === \"append\" && fs.existsSync(fullPath)) {\n            try {\n                existingContent = fs.readFileSync(fullPath, 'utf8');\n                // node.log(\"Bestehenden Dateiinhalt erfolgreich gelesen.\");\n            } catch (err) {\n                node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n            }\n        }\n\n        // 6) Dateiinhalt erstellen\n        var fileContents = buildFileContents(bufferToSave, config.fileFormat, existingContent);\n        // node.log(\"Dateiinhalt erstellt.\");\n\n        // 7) Datei schreiben\n        fs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n            if (err) {\n                node.error(\"File write error: \" + err.message);\n                updateStatus(\"Saving error\", \"red\", \"ring\");\n            } else {\n                // node.log(\"Datei erfolgreich gespeichert: \" + fullPath);\n                updateStatus(\"Data saved (\" + bufferToSave.length + \" items)\", \"green\", \"dot\");\n            }\n        });\n\n        // 8) Buffer & Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n        // node.log(\"Buffer und Timer-Flag zurückgesetzt.\");\n\n    }, config.intervalMs);\n}\n\n// Keine reguläre Ausgabe\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 450,
        "y": 80,
        "wires": []
    },
    {
        "id": "e78f387d4ba01882",
        "type": "mqtt in",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 80,
        "wires": [
            [
                "424f5da4789c7d8e"
            ]
        ]
    },
    {
        "id": "a101bcd063f6e0e4",
        "type": "status",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "scope": null,
        "x": 360,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "7305073267fb70ed",
        "type": "status",
        "z": "dac356dc77e3d814",
        "name": "",
        "scope": [
            "bcee19f0a4e24893"
        ],
        "x": 420,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "bcee19f0a4e24893",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\n// Hilfsfunktion für Fallback-Reihenfolge\nfunction getVar(key, def) {\n    if (msg && msg.payload && msg.payload[key] !== undefined) {\n        return msg.payload[key];\n    }\n    if (msg && msg.params && msg.params[key] !== undefined) {\n        return msg.params[key];\n    }\n    return env.get(key) || def;\n}\n\nconst endpoint = getVar(\"OPC_ENDPOINT\", \"opc.tcp://192.168.0.84:48010\");\nconst objectId = getVar(\"M_NODE_PARENT\", \"ns=3;s=Demo.Method\");\nconst methodId = getVar(\"M_NODE_IMAGE\", \"ns=3;s=Demo.Method.DoSomethingAfter10s\");\nconst methodArgs = getVar(\"M_ARGS\", \"\");\nconst checkNodeId = getVar(\"NODE_CHECK\", \"ns=3;s=Demo.Dynamic.Scalar.Boolean\");\nconst imageNodeId = getVar(\"NODE_IMAGE\", \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\");\nconst ackNodeId = getVar(\"NODE_ACK_READ\", \"ns=3;s=Demo.Dynamic.Scalar.Boolean\");\nconst basePath = getVar(\"BASEPATH\", \"./data/images\");\nconst device = getVar(\"DEVICE_ID\", \"local-1\");\nconst enableUpload = String(getVar(\"ENABLE_UPLOAD\", \"false\")).toLowerCase();\nconst uploadUrl = getVar(\"UPLOAD_URL\", null);\nconst timeHeader = getVar(\"TIMESTAMP_HEADER_NAME\", null);\nconst processId = getVar(\"PROCESS_ID\", null);\n\nlet headersRaw = getVar(\"HEADERS\", { \"Content-Type\": \"application/octet-stream\" });\nconst additionalHeaders = typeof headersRaw === \"string\" ? JSON.parse(headersRaw) : headersRaw;\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"KIOekoSys_Gateway_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 10\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        savedFilePath = await saveImage(base64String, basePath, device);\n        node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders, timeHeader);\n            node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n            process_id: processId,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}, timerHeader) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n\n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // Add the timestamp header if a name is specified\n    if (timerHeader && typeof timerHeader === 'string') {\n        const timestampHeaderValue = new Date().toISOString();\n        mergedHeaders[timerHeader] = timestampHeaderValue;\n    }\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\nreturn main().then(\n    finalMsg => {\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n        return finalMsg;\n    },\n    err => {\n        node.error(err.message, msg);\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n        node.warn(\"[DEBUG] Caught error: \" + err.message);\n        return null;\n    }\n);\n// return main().then(\n//     finalMsg => finalMsg,\n//     err => null\n// );",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 410,
        "y": 200,
        "wires": [
            [
                "c7d47dd6e033c7ef"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "c7d47dd6e033c7ef",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 280,
        "wires": [
            [
                "f64651dd0ef28470"
            ]
        ]
    },
    {
        "id": "f64651dd0ef28470",
        "type": "http request",
        "z": "dac356dc77e3d814",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "d7352d4373f17731",
        "type": "http in",
        "z": "dac356dc77e3d814",
        "name": "",
        "url": "/api/img-capture",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 340,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "5ba6931c61bc49e0",
        "type": "file",
        "z": "dac356dc77e3d814",
        "name": "",
        "filename": "",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 540,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "498350a0e7d7fa21",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER\"); // Erwartet einen numerischen Wert in Sekunden\n\nmsg.startTime = process.hrtime();\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 60; // Standard: 1 Minute (60 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 330,
        "y": 160,
        "wires": [
            [
                "8b0261fb901db5f1"
            ]
        ]
    },
    {
        "id": "92542095e6a14c91",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "prepare data",
        "func": "// Node-RED Function: Datenvorbereitung (Prepare) - für HTTP-Request\n// - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n// - Transformiert diese in das gewünschte JSON-Format.\n// - Fügt die URL, Methode und Header zu msg hinzu.\n// - Aktualisiert ausschließlich den Status (node.status).\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers = env.get(\"HEADER\") || msg.headers;\n\n// Prüfe, ob die Startzeit vorhanden ist\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Fehler: Keine Startzeit!\" } };\n}\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Kein Data zu senden\" } };\n}\n\n// Status: Transformiere Daten...\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Transform Data ...\" });\n\nvar transformedPayload;\nif (Array.isArray(msg.payload)) {\n    transformedPayload = msg.payload.map(entry => {\n        return {\n            \"DatapointID\": entry.datapointId,\n            \"Value\": String(entry._value),\n            \"Timestamp\": formatTimestamp(entry._time)\n        };\n    });\n} else {\n    // Fallback für den Fall, dass msg.payload ein einzelnes Objekt ist\n    transformedPayload = {\n        \"DatapointID\": msg.payload.datapointId,\n        \"Value\": String(msg.payload._value),\n        \"Timestamp\": formatTimestamp(msg.payload._time)\n    };\n}\n\n// Create a new msg object to ensure only relevant data is passed\nconst newMsg = {};\n\n// Prepare the new msg object for the next node\n// newMsg.url = endpoint;\n// newMsg.method = 'POST';\nnewMsg.headers = Object.assign({}, headers, {\n    'Content-Type': 'application/json'\n});\nnewMsg.payload = JSON.stringify(transformedPayload);\n\n// Status: Data prepared\nnode.status({ fill: \"green\", shape: \"dot\", text: \"Daten vorbereitet.\" });\n\n// Return the new, clean message object\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 670,
        "y": 160,
        "wires": [
            [
                "bea5ddd6f28b31e6"
            ]
        ]
    },
    {
        "id": "16c9290388d72e82",
        "type": "status",
        "z": "ef4290a715908540",
        "name": "",
        "scope": [
            "909cfd3350ca8386",
            "0e226ce77eeb9e38",
            "0d0927f611cb7ec5",
            "2f2bbe367a92dd21"
        ],
        "x": 260,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "8b0261fb901db5f1",
        "type": "influxdb in",
        "z": "ef4290a715908540",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 500,
        "y": 160,
        "wires": [
            [
                "92542095e6a14c91"
            ]
        ]
    },
    {
        "id": "bea5ddd6f28b31e6",
        "type": "http request",
        "z": "ef4290a715908540",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "${URL}",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 690,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "f149fa1419532405",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "http send - old",
        "func": "/**\n * Node-RED Function: Datenversand (Send) - für InfluxDB-Daten\n *\n * - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n * - Versendet diese per HTTP POST an den konfigurierten Endpoint.\n * - HTTP-Header und Endpoint können über Umgebungsvariablen (env) oder msg überschrieben werden.\n * - Aktualisiert ausschließlich den Status (node.status).\n */\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers = env.get(\"HEADER\") || msg.headers;\n\n// Prüfe, ob die Startzeit vorhanden ist\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Fehler: Keine Startzeit!\" } };\n}\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Kein Data zu senden\" } };\n}\n\n// Status: Transformiere Daten...\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Transform Data ...\" });\n\nif (Array.isArray(msg.payload)) {\n    msg.payload = msg.payload.map(entry => {\n        return {\n            \"DatapointID\": entry.datapointId,\n            \"Value\": String(entry._value),\n            \"Timestamp\": formatTimestamp(entry._time)\n        };\n    });\n} else {\n    // Fallback für den Fall, dass msg.payload ein einzelnes Objekt ist\n    msg.payload = {\n        \"DatapointID\": msg.payload.datapointId,\n        \"Value\": String(msg.payload._value),\n        \"Timestamp\": formatTimestamp(msg.payload._time)\n    };\n}\n\n// Status: Sende Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Send Data ...\" });\n\n// Erstelle den POST-Datenstring (JSON) aus msg.payload\nvar postData = JSON.stringify(msg.payload);\n\n// Zerlege den Endpoint in seine Bestandteile\nvar endpointUrl = url.parse(endpoint);\nvar options = {\n    hostname: endpointUrl.hostname,\n    port: endpointUrl.port,\n    path: endpointUrl.path,\n    method: 'POST',\n    timeout: 30000,\n    headers: Object.assign({}, headers, {\n        'Content-Length': Buffer.byteLength(postData),\n        'Content-Type': 'application/json'\n    })\n};\n\n// Initialisiere den HTTP POST Request\nvar req = http.request(options, function (res) {\n    var responseBody = \"\";\n    res.setEncoding('utf8');\n    res.on('data', function (chunk) {\n        responseBody += chunk;\n    });\n    res.on('end', function () {\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n            var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n            node.status({\n                fill: \"green\",\n                shape: \"dot\",\n                text: `${entryCount} Einträge versendet, Dauer: ${durationMs.toFixed(2)} ms`\n            });\n            // Erfolgsmeldung zurückgeben\n            node.send({ payload: { success: `Datenversand erfolgreich. ${entryCount} Einträge.` } });\n        } else {\n            const errorMessage = `Versand fehlgeschlagen (Status ${res.statusCode}): ${responseBody}`;\n            node.error(errorMessage);\n            node.status({ fill: \"red\", shape: \"ring\", text: `Versand fehlgeschlagen (Status ${res.statusCode})` });\n            // Fehlermeldung zurückgeben\n            node.send({ payload: { error: errorMessage } });\n        }\n    });\n});\n\n// Füge den 'timeout' Event-Handler hinzu\nreq.on('timeout', function () {\n    const errorMessage = 'Request timed out after 30 seconds.';\n    req.destroy(new Error(errorMessage));\n    node.error(errorMessage);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Versand fehlgeschlagen: Timeout\" });\n    // Fehlermeldung zurückgeben\n    node.send({ payload: { error: errorMessage } });\n});\n\nreq.on('error', function (e) {\n    const errorMessage = `HTTP POST request error: ${e.message}`;\n    node.error(errorMessage);\n    node.status({ fill: \"red\", shape: \"ring\", text: `Versand fehlgeschlagen: ${e.message}` });\n    // Fehlermeldung zurückgeben\n    node.send({ payload: { error: errorMessage } });\n});\n\n// Sende den POST-Datenstring\nreq.write(postData);\nreq.end();\n\n// WICHTIG: Kein Return hier, da die Rückgabe im asynchronen Callback stattfindet.\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 660,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "909cfd3350ca8386",
        "type": "function",
        "z": "ef4290a715908540",
        "g": "78414965a2b1d621",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER\"); // Erwartet einen numerischen Wert in Sekunden\n\nmsg.startTime = process.hrtime();\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 60; // Standard: 1 Minute (60 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 490,
        "y": 540,
        "wires": [
            [
                "2f2bbe367a92dd21"
            ]
        ]
    },
    {
        "id": "0e226ce77eeb9e38",
        "type": "function",
        "z": "ef4290a715908540",
        "g": "78414965a2b1d621",
        "name": "prepare data",
        "func": "// Node-RED Function: Datenvorbereitung (Prepare) - für HTTP-Request\n// - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n// - Transformiert diese in das gewünschte JSON-Format.\n// - Fügt die URL, Methode und Header zu msg hinzu.\n// - Aktualisiert ausschließlich den Status (node.status).\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers = env.get(\"HEADER\") || msg.headers;\n\n// Prüfe, ob die Startzeit vorhanden ist\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Fehler: Keine Startzeit!\" } };\n}\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    // Rückgabe einer Fehlermeldung\n    return { payload: { error: \"Kein Data zu senden\" } };\n}\n\n// Status: Transformiere Daten...\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Transform Data ...\" });\n\nvar transformedPayload;\nif (Array.isArray(msg.payload)) {\n    transformedPayload = msg.payload.map(entry => {\n        return {\n            \"DatapointID\": entry.datapointId,\n            \"Value\": String(entry._value),\n            \"Timestamp\": formatTimestamp(entry._time)\n        };\n    });\n} else {\n    // Fallback für den Fall, dass msg.payload ein einzelnes Objekt ist\n    transformedPayload = {\n        \"DatapointID\": msg.payload.datapointId,\n        \"Value\": String(msg.payload._value),\n        \"Timestamp\": formatTimestamp(msg.payload._time)\n    };\n}\n\n// Create a new msg object to ensure only relevant data is passed\nconst newMsg = {};\n\n// Prepare the new msg object for the next node\n// newMsg.url = endpoint;\n// newMsg.method = 'POST';\nnewMsg.headers = Object.assign({}, headers, {\n    'Content-Type': 'application/json'\n});\nnewMsg.payload = JSON.stringify(transformedPayload);\nnewMsg.data = JSON.stringify(transformedPayload);\n\n// Status: Data prepared\nnode.status({ fill: \"green\", shape: \"dot\", text: \"Daten vorbereitet.\" });\n\n// Return the new, clean message object\nreturn newMsg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 830,
        "y": 540,
        "wires": [
            [
                "0d0927f611cb7ec5"
            ]
        ]
    },
    {
        "id": "dff4cd78f67f45a4",
        "type": "inject",
        "z": "ef4290a715908540",
        "g": "78414965a2b1d621",
        "name": "",
        "props": [],
        "repeat": "${TIMER}",
        "crontab": "",
        "once": true,
        "onceDelay": "${TIMER}",
        "topic": "",
        "x": 280,
        "y": 540,
        "wires": [
            [
                "909cfd3350ca8386"
            ]
        ]
    },
    {
        "id": "2f2bbe367a92dd21",
        "type": "influxdb in",
        "z": "ef4290a715908540",
        "g": "78414965a2b1d621",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 660,
        "y": 540,
        "wires": [
            [
                "0e226ce77eeb9e38"
            ]
        ]
    },
    {
        "id": "0d0927f611cb7ec5",
        "type": "http request",
        "z": "ef4290a715908540",
        "g": "78414965a2b1d621",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "${URL}",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 850,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "4a16a8db342b7323",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER\"); // Erwartet einen numerischen Wert in Sekunden\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 60; // Standard: 1 min\n}\n\n// Erfassen des Startzeitpunktes\nmsg.startTime = process.hrtime();\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 330,
        "y": 180,
        "wires": [
            [
                "fa7abbee5d7c7eb7"
            ]
        ]
    },
    {
        "id": "a2fa737c0195922b",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "influx-to-file",
        "func": "/**\n * Node-RED Function: Speichert die empfangenen Daten in eine Datei.\n *\n * - Unterstützt verschiedene Formate (JSON, CSV, XML).\n * - Kann entweder an eine Datei anhängen oder eine neue Datei mit Timestamp erstellen.\n * - Erstellt automatisch das Verzeichnis, falls es nicht existiert.\n * - Aktualisiert den Node-Status entsprechend.\n */\n\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    return null;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n// Konfiguration aus Umgebungsvariablen oder msg übernehmen\nvar filePath = env.get(\"FOLDER\") || msg.filePath || \"/files\";  // Standardverzeichnis\nvar fileName = env.get(\"FILENAME\") || msg.fileName || \"influx_data\"; // Basis-Dateiname\nvar fileMode = env.get(\"FILE_MODE\") || msg.fileMode || \"append\"; // \"append\" oder \"new\"\nvar fileFormat = (env.get(\"FORMAT\") || msg.fileFormat || \"json\").toLowerCase(); // \"json\", \"csv\", \"xml\"\n\n// Überprüfen, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Keine Daten zu speichern\" });\n    return null;\n}\n\n// Status: Speichern der Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Speichere Daten...\" });\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Funktion zur Umwandlung der Daten in das gewünschte Format\nfunction convertData(data, format, existingContent = \"\") {\n    // Umwandlung der Datenstruktur\n    let transformedData = data.map(item => ({\n        DatapointId: item.datapointId,\n        Value: item._value,\n        Timestamp: formatTimestamp(item._time)\n    }));\n\n    if (format === \"json\") {\n        if (fileMode === \"append\" && existingContent) {\n            try {\n                let existingData = JSON.parse(existingContent);\n                if (Array.isArray(existingData)) {\n                    existingData.push(...transformedData);\n                } else {\n                    existingData = [...transformedData];\n                }\n                return JSON.stringify(existingData, null, 2);\n            } catch (err) {\n                node.error(\"JSON Parsing Error: \" + err.message);\n            }\n        }\n        return JSON.stringify(transformedData, null, 2);\n    }\n    if (format === \"csv\") {\n        let keys = [\"DatapointId\", \"Value\", \"Timestamp\"];\n        let csvRows = transformedData.map(row => keys.map(k => row[k]).join(\",\"));\n        if (fileMode === \"append\" && existingContent) {\n            return existingContent + \"\\n\" + csvRows.join(\"\\n\");\n        }\n        return keys.join(\",\") + \"\\n\" + csvRows.join(\"\\n\");\n    }\n    if (format === \"xml\") {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<data>\\n';\n        transformedData.forEach(item => {\n            xml += \"  <entry>\\n\";\n            xml += `    <DatapointId>${item.DatapointId}</DatapointId>\\n`;\n            xml += `    <Value>${item.Value}</Value>\\n`;\n            xml += `    <Timestamp>${item.Timestamp}</Timestamp>\\n`;\n            xml += \"  </entry>\\n\";\n        });\n        xml += \"</data>\";\n        return xml;\n    }\n    return JSON.stringify(transformedData, null, 2); // Fallback: JSON\n}\n\n\n// Dateiname & Pfad ermitteln\nvar fileExtension = fileFormat === \"xml\" ? \"xml\" : fileFormat === \"csv\" ? \"csv\" : \"json\";\nvar finalFileName = fileMode === \"new\"\n    ? `${fileName}_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExtension}`\n    : `${fileName}.${fileExtension}`;\nvar folderPath = path.join(\"/data/shared/\", filePath);\nvar fullPath = path.join(folderPath, finalFileName);\nnode.log(fullPath);\n\n// Falls nötig, Verzeichnis erstellen\ntry {\n    fs.mkdirSync(folderPath, { recursive: true });\n} catch (e) {\n    node.error(\"Fehler beim Erstellen des Verzeichnisses: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Verzeichnisfehler\" });\n    return null;\n}\n\n// Falls append-Modus, existierenden Inhalt lesen\nlet existingContent = \"\";\nif (fileMode === \"append\" && fs.existsSync(fullPath)) {\n    try {\n        existingContent = fs.readFileSync(fullPath, 'utf8');\n    } catch (err) {\n        node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n    }\n}\n\n// Dateiinhalt generieren\nvar fileContents = convertData(msg.payload, fileFormat, existingContent);\n\n// Datei schreiben\nfs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n    if (err) {\n        node.error(\"Fehler beim Speichern der Datei: \" + err.message);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Speichern fehlgeschlagen\" });\n    } else {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: `${entryCount} Einträge, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n            // text: `Gespeichert (${entryCount} Einträge), Dauer: ${durationMs.toFixed(2)} ms, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n        });\n\n        // Ausgabe der Zeitmessung für Debugging\n        node.log(`Datei gespeichert in ${durationMs.toFixed(2)} ms: ${fullPath}`);\n    }\n});\n\n// Keine Weitergabe der Nachricht\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 670,
        "y": 180,
        "wires": []
    },
    {
        "id": "71c0dcf56b57e3e9",
        "type": "status",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "scope": null,
        "x": 60,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "1f74a5f312e69b31",
        "type": "inject",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "props": [],
        "repeat": "${TIMER}",
        "crontab": "",
        "once": true,
        "onceDelay": "${TIMER}",
        "topic": "",
        "x": 150,
        "y": 180,
        "wires": [
            [
                "4a16a8db342b7323"
            ]
        ]
    },
    {
        "id": "fa7abbee5d7c7eb7",
        "type": "influxdb in",
        "z": "f5c5556a9e4eb0ae",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 500,
        "y": 180,
        "wires": [
            [
                "a2fa737c0195922b"
            ]
        ]
    },
    {
        "id": "3502dba94720d721",
        "type": "function",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "save local - no url",
        "func": "const uploaded = msg.statusCode;\nconst device_id = msg.opcua.device_id;\nconst timestamp = msg.opcua.timestamp;\n\n// Prüfe, ob der Upload fehlgeschlagen ist (statusCode nicht 200 oder 201)\nif (uploaded !== 200 && uploaded !== 201) {\n\n    node.status({ fill: \"red\", shape: \"ring\", text: `Upload failed with status code ${uploaded}. Saving file...` });\n\n    // Bilddaten aus dem ursprünglichen Payload holen\n    let imageData = msg.payload;\n\n    // Optional: Konvertiere das Bild in Base64, falls nötig\n    // Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n    // Ein Dateiknoten speichert Buffer direkt korrekt.\n    // Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\n    const base64Image = imageData.toString(\"base64\");\n\n    // Definiere den Speicherpfad\n    const today = new Date().toISOString().slice(0, 10);\n    // const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n    // Setze den Dateinamen im msg-Objekt\n    // Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\n    msg.filename = `/data/shared/${today}/${device_id}_${timestamp}.png`;\n\n    // Setze den Payload auf die reinen Bilddaten (als Buffer)\n    // msg.payload = imageData;\n\n    // Setze den payload auf die Bilddaten (base64)\n    msg.payload = base64Image \n\n    node.status({ fill: \"green\", shape: \"dot\", text: 'Saved local' });\n\n    // Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n    // Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\n    return msg;\n} else {\n    // Erfolgreicher Upload\n    node.status({ fill: \"green\", shape: \"dot\", text: `Upload successful with status code ${uploaded}.` });\n\n    // Gib eine leere Nachricht oder einen Erfolgs-Payload zurück, um den Flow fortzusetzen\n    msg.payload = { success: true, message: `Upload successful for device ${device_id}.` };\n\n    // Optional: Lösche das Bild, um Speicher zu sparen\n    delete msg.payload.image;\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 420,
        "wires": [
            [
                "b8081502c40f9291"
            ]
        ]
    },
    {
        "id": "445e86533b09c2a0",
        "type": "http in",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "",
        "url": "/api/img-capture",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 220,
        "wires": [
            [
                "4a78acdb944cb3d8",
                "d662cc824562b25b"
            ]
        ]
    },
    {
        "id": "b8081502c40f9291",
        "type": "file",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 860,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "289ee7041572313b",
        "type": "http request",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "body",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 330,
        "y": 460,
        "wires": [
            [
                "2c5e65cc7b5c67c6"
            ]
        ]
    },
    {
        "id": "4a78acdb944cb3d8",
        "type": "function",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process - Vorbereitung für externen HTTP-Request\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\n// Hilfsfunktion für Fallback-Reihenfolge\nfunction getVar(key, def) {\n    if (msg && msg.payload && msg.payload[key] !== undefined) {\n        return msg.payload[key];\n    }\n    if (msg && msg.params && msg.params[key] !== undefined) {\n        return msg.params[key];\n    }\n    return env.get(key) || def;\n}\n\nconst endpoint = getVar(\"OPC_ENDPOINT\", \"opc.tcp://192.168.0.84:48010\");\nconst objectId = getVar(\"M_NODE_PARENT\", \"ns=3;s=Demo.Method\");\nconst methodId = getVar(\"M_NODE_IMAGE\", \"ns=3;s=Demo.Method.DoSomethingAfter10s\");\nconst methodArgs = getVar(\"M_ARGS\", \"\");\nconst readAvailableNodeId = getVar(\"NODE_READ_AVAILABLE\", \"ns=3;s=Demo.Dynamic.Scalar.Boolean\");\nconst checkNodeId = getVar(\"NODE_CHECK\", \"ns=3;s=Demo.Dynamic.Scalar.Boolean\");\nconst imageNodeId = getVar(\"NODE_IMAGE\", \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\");\nconst ackNodeId = getVar(\"NODE_ACK_READ\", \"ns=3;s=Demo.Dynamic.Scalar.Boolean\");\nconst basePath = getVar(\"BASEPATH\", \"./data/images\");\nconst device = getVar(\"DEVICE_ID\", \"local-1\");\nconst enableUpload = String(getVar(\"ENABLE_UPLOAD\", \"false\")).toLowerCase();\nconst uploadUrl = getVar(\"UPLOAD_URL\", null);\nconst timeHeader = getVar(\"TIMESTAMP_HEADER_NAME\", null);\nconst processId = getVar(\"PROCESS_ID\", null);\n\nlet headersRaw = getVar(\"HEADERS\", { \"Content-Type\": \"application/octet-stream\" });\nconst additionalHeaders = typeof headersRaw === \"string\" ? JSON.parse(headersRaw) : headersRaw;\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username = env.get(\"OPC_USER\");\nconst password = env.get(\"OPC_PW\");\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n\n    let connectionCache = global.get(\"opcuaConnections\") || {};\n\n    try {\n        const clientName = \"KIOekoSys_Gateway_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // Prüfen, ob bereits eine aktive Verbindung für diesen Endpoint existiert\n        if (connectionCache[endpoint] && connectionCache[endpoint].session) {\n            session = connectionCache[endpoint].session;\n            client = connectionCache[endpoint].client;\n            node.status({ fill: \"green\", shape: \"ring\", text: \"Reusing existing session\" });\n            node.log(`[DEBUG] Reusing existing OPC UA session for ${endpoint}`);\n        } else {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Creating new client/session\" });\n            node.log(`[DEBUG] Creating new OPC UA session for ${endpoint}`);\n\n            // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n            client = opcua.OPCUAClient.create({\n                applicationName: clientName,\n                endpointMustExist: false,\n                securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n                securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n                connectionStrategy: {\n                    initialDelay: 1000,\n                    maxRetry: 5\n                }\n            });\n\n            await client.connect(endpoint);\n\n            let userIdentity = null;\n            if (username && password) {\n                userIdentity = { userName: username, password };\n            }\n\n            session = await client.createSession(userIdentity);\n            connectionCache[endpoint] = { client, session, lastUsed: Date.now() };\n\n            // Speichern im globalen Kontext\n            global.set(\"opcuaConnections\", connectionCache);\n            node.log(`[DEBUG] OPC UA session created and cached for ${endpoint}`);\n        }\n\n        // 7) Warten, bis Image_Read_Available_node = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for Image Read available ...\" });\n        //await waitForBooleanTrue(session, readAvailableNodeId, 10000);\n        node.log(`[DEBUG] Wait till check node true...`);\n\n        // 7.1) Setze ImageWasRead auf True falls noch nicht zuvor\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        node.log(`[DEBUG] wrote ack node`);\n\n        // 8) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // // 9) Warten, bis checkNodeId = true\n        // node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        // await waitForBooleanTrue(session, checkNodeId, 20000);\n        // node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Warten, bis checkNodeId = true (jetzt für mehrere Nodes)\n        const checkNodes = checkNodeId.split(',').map(s => s.trim()).filter(Boolean);\n        if (checkNodes.length > 0) {\n            for (const nodeId of checkNodes) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: `Wait for boolean on ${nodeId}...` });\n                await waitForBooleanTrue(session, nodeId, 20000);\n                node.log(`[DEBUG] Wait till check node ${nodeId} true...`);\n            }\n        } else {\n            node.log(\"[WARN] checkNodeId is empty, skipping boolean check.\");\n        }\n\n        // 10) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        node.log(`[DEBUG] read image string`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Lokales Speichern falls Upload nicht aktiviert ist\n        if (enableUpload !== \"true\") {\n            node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n            savedFilePath = await saveImage(base64String, basePath, device);\n            node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n        }\n\n        // 13) Finaler Node-Status\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Image capture done\" });\n\n        // 14) msg-Objekt für den nächsten Node vorbereiten\n        const finalMsg = {};\n        finalMsg.payload = Buffer.from(base64String, \"base64\");\n        finalMsg.image_base64 = base64String.toString(\"base64\")\n\n        if (enableUpload === \"true\" && uploadUrl) {\n            finalMsg.url = uploadUrl;\n            finalMsg.method = 'POST';\n            finalMsg.image = base64String;\n            finalMsg.headers = {\n                ...additionalHeaders\n            };\n            if (timeHeader) {\n                finalMsg.headers[timeHeader] = formatDate(new Date());\n            }\n        }\n\n        // Zusätzliche Metadaten für Debugging oder weitere Flow-Schritte\n        finalMsg.topic = \"image_capture_complete\";\n        finalMsg.opcua = {\n            success: true,\n            image: base64String,\n            endpoint,\n            uploaded: (enableUpload === \"true\"),\n            device_id: device,\n            processId: processId,\n            timestamp: new Date().toISOString().replace(/[:.]/g, \"-\")\n        };\n\n        return finalMsg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Wenn ein Fehler aufgetreten ist → Verbindung schließen\n        if (errorOccurred) {\n            node.warn(`[DEBUG] Error detected, closing OPC UA session for ${endpoint}`);\n\n            // Verbindung aus Cache entfernen\n            let connectionCache = global.get(\"opcuaConnections\") || {};\n            if (connectionCache[endpoint]) {\n                delete connectionCache[endpoint];\n                global.set(\"opcuaConnections\", connectionCache);\n            }\n\n            // Session schließen\n            if (session) {\n                try {\n                    await session.close();\n                    node.log(`[DEBUG] Session closed for ${endpoint}`);\n                } catch (closeErr) {\n                    node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n                }\n            }\n\n            // Client trennen\n            if (client) {\n                try {\n                    await client.disconnect();\n                    node.log(`[DEBUG] Client disconnected for ${endpoint}`);\n                } catch (disconnectErr) {\n                    node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n                }\n            }\n\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            // Erfolgreicher Lauf: Session aktiv halten\n            if (session && client) {\n                const connectionCache = global.get(\"opcuaConnections\") || {};\n                if (connectionCache[endpoint]) {\n                    connectionCache[endpoint].lastUsed = Date.now();\n                    global.set(\"opcuaConnections\", connectionCache);\n                }\n            }\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done (session kept open)\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n// Note: axios and http-related functions have been removed.\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n\n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && (dataValue.value.value === true || dataValue.value.value === 1)) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000);\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n    await fs.ensureDir(`${basePath}/${device}`);\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nfunction formatDate(date, format) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    const hours = String(date.getHours()).padStart(2, '0');\n    const minutes = String(date.getMinutes()).padStart(2, '0');\n    const seconds = String(date.getSeconds()).padStart(2, '0');\n    if (format === 'ISO') {\n        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;\n    }\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\nreturn main().then(\n    finalMsg => {\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n        return finalMsg;\n    },\n    err => {\n        node.error(err.message, msg);\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n        node.warn(\"[DEBUG] Caught error: \" + err.message);\n        return null;\n    }\n);",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 310,
        "y": 320,
        "wires": [
            [
                "ddce54b01f874280",
                "3292cba161de8b89"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "ddce54b01f874280",
        "type": "function",
        "z": "acb6954d7bc4254f",
        "g": "fd15d59808abbc1e",
        "name": "Forward Image to Gateway",
        "func": "const image = msg.payload;\nconst device_id = msg.opcua.device_id;\nconst process_id = msg.opcua.processId;\nconst upload_url = msg.url;\n\nconst base64image = image.toString(\"base64\");\n\nconst d = new Date();\n\n// Get timezone offset in minutes (inkl. Sommer/Winterzeit)\nconst offsetMinutes = d.getTimezoneOffset();\n\n// Lokale Zeit = UTC-Zeit minus Offset\nconst localTime = new Date(d.getTime() - offsetMinutes * 60000);\n\n// ISO-String der lokalen Zeit (ohne Z am Ende)\nconst isoStringLocal = localTime.toISOString().slice(0, -1);\n\n// Offset-Format (+01:00 oder +02:00 für Deutschland)\nconst offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\nconst offsetRemainingMinutes = Math.abs(offsetMinutes) % 60;\nconst offsetSign = offsetMinutes > 0 ? \"-\" : \"+\";\nconst offsetFormatted = `${offsetSign}${String(offsetHours).padStart(2, \"0\")}:${String(offsetRemainingMinutes).padStart(2, \"0\")}`;\n\n// Finaler Zeitstempel\nconst timestamp = isoStringLocal + offsetFormatted;\n\nconst newMsg = {};\nnewMsg.payload = {\n    \"device_id\": device_id,\n    \"process_id\": process_id,\n    \"last_execution\": timestamp,\n    \"image\": base64image,\n    \"upload_url\": upload_url\n};\n\nreturn newMsg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 320,
        "wires": [
            [
                "b9a7313e92123d8d"
            ]
        ]
    },
    {
        "id": "55b87dd8a941aea8",
        "type": "http response",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 620,
        "y": 220,
        "wires": []
    },
    {
        "id": "b9a7313e92123d8d",
        "type": "http request",
        "z": "acb6954d7bc4254f",
        "g": "fd15d59808abbc1e",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 890,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "d662cc824562b25b",
        "type": "delay",
        "z": "acb6954d7bc4254f",
        "g": "3fe1ed64fcf761ad",
        "name": "",
        "pauseType": "random",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "3",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 390,
        "y": 220,
        "wires": [
            [
                "55b87dd8a941aea8"
            ]
        ]
    },
    {
        "id": "061e48c71685d276",
        "type": "status",
        "z": "acb6954d7bc4254f",
        "name": "",
        "scope": [
            "445e86533b09c2a0",
            "289ee7041572313b",
            "4a78acdb944cb3d8",
            "3292cba161de8b89",
            "cba1a0b3d2a37ad4",
            "2718793c3a462335",
            "3502dba94720d721"
        ],
        "x": 520,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "3292cba161de8b89",
        "type": "switch",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "",
        "property": "url",
        "propertyType": "msg",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "empty"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 170,
        "y": 440,
        "wires": [
            [
                "3502dba94720d721"
            ],
            [
                "3502dba94720d721"
            ],
            [
                "289ee7041572313b"
            ]
        ]
    },
    {
        "id": "2c5e65cc7b5c67c6",
        "type": "switch",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "gte",
                "v": "300",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 510,
        "y": 540,
        "wires": [
            [
                "cba1a0b3d2a37ad4"
            ],
            [
                "2718793c3a462335"
            ]
        ]
    },
    {
        "id": "cba1a0b3d2a37ad4",
        "type": "function",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "save local - upload failed",
        "func": "const uploaded = msg.statusCode;\nconst device_id = msg.opcua.device_id;\n\n// Prüfe, ob der Upload fehlgeschlagen ist (statusCode nicht 200 oder 201)\nif (uploaded !== 200 && uploaded !== 201) {\n\n    node.status({ fill: \"red\", shape: \"ring\", text: `Upload failed with status code ${uploaded}. Saving file...` });\n\n    // Bilddaten aus dem ursprünglichen Payload holen\n    let imageData = msg.image;\n\n    // Optional: Konvertiere das Bild in Base64, falls nötig\n    // Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n    // Ein Dateiknoten speichert Buffer direkt korrekt.\n    // Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\n    const base64Image = imageData.toString(\"base64\");\n\n    // Definiere den Speicherpfad\n    const today = new Date().toISOString().slice(0, 10);\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n    // Setze den Dateinamen im msg-Objekt\n    // Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\n    msg.filename = `/data/shared/${today}/${device_id}_${timestamp}.png`;\n\n    // Setze den Payload auf die reinen Bilddaten (als Buffer)\n    // msg.payload = imageData;\n\n    // Setze den payload auf die Bilddaten (base64)\n    msg.payload = base64Image \n\n    node.status({ fill: \"green\", shape: \"ring\", text: `File saved local` });\n\n\n    // Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n    // Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\n    return msg;\n} else {\n    // Erfolgreicher Upload\n    node.status({ fill: \"green\", shape: \"dot\", text: `Upload successful with status code ${uploaded}.` });\n\n    // Gib eine leere Nachricht oder einen Erfolgs-Payload zurück, um den Flow fortzusetzen\n    msg.payload = { success: true, message: `Upload successful for device ${device_id}.` };\n\n    // Optional: Lösche das Bild, um Speicher zu sparen\n    delete msg.payload.image;\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 520,
        "wires": [
            [
                "1ccd8789af4f86fd"
            ]
        ]
    },
    {
        "id": "1ccd8789af4f86fd",
        "type": "file",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 900,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "2718793c3a462335",
        "type": "function",
        "z": "acb6954d7bc4254f",
        "g": "2bf0ffb2de7e1870",
        "name": "success",
        "func": "// Erfolgreicher Upload\nnode.status({ fill: \"green\", shape: \"dot\", text: `Upload successful` });",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "107022b96f1aab5e",
        "type": "mqtt in",
        "z": "10d72cae5a6340f6",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "2f805d2340572b54"
            ]
        ]
    },
    {
        "id": "05d51a8734299975",
        "type": "status",
        "z": "10d72cae5a6340f6",
        "name": "",
        "scope": [
            "0e88cf4f502b4eef",
            "2f805d2340572b54",
            "7e11d1fd34b1bb7c",
            "68d583883eeab06d",
            "107022b96f1aab5e"
        ],
        "x": 320,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "0e88cf4f502b4eef",
        "type": "http request",
        "z": "10d72cae5a6340f6",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "${URL}",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 450,
        "y": 320,
        "wires": [
            [
                "8d9a24255f3aa6fa"
            ]
        ]
    },
    {
        "id": "2f805d2340572b54",
        "type": "function",
        "z": "10d72cae5a6340f6",
        "name": "collect & send data REST",
        "func": "// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Konfiguration\nvar config = {\n    topicSeparator: '/'\n};\n\n// ==============================\n// Datenpunkt erfassen und in den Buffer einfügen\n// ==============================\nvar buffer = context.get('buffer') || [];\n\n// Extrahiere die numerische ID aus msg.topic.\nvar idMatch = msg.topic.match(/\\[(\\d+)\\]/);\nvar datapointId = idMatch ? idMatch[1] : null;\n\n// Wenn keine gültige ID gefunden wurde, verwerfe die Nachricht.\nif (!datapointId) {\n    node.warn(\"Invalid DatapointID in topic: \" + msg.topic);\n    return null;\n}\n\n// Erstelle einen neuen Datenpunkt-Eintrag\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    // Verwende die formatTimestamp-Funktion, um den Zeitstempel zu formatieren\n    Timestamp: formatTimestamp(new Date().toISOString())\n};\n\n// Füge den Datenpunkt dem Buffer hinzu\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n\n// Status: Sammeln\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Collect (\" + buffer.length + \" items)\" });\n\n// ==============================\n// Timer-Logik: Versand des Buffers nach Zeit, falls nicht bereits gesetzt\n// ==============================\nvar timerDelay = msg.timerDelay || (env.get(\"INTERVAL (sec)\") * 1000);\nvar timerSet = context.get('timerSet') || false;\n\nif (!timerSet) {\n    context.set('timerSet', true);\n    setTimeout(function () {\n        // Status: Sende Daten...\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"Send Data...\" });\n\n        // Lese den aktuell gespeicherten Buffer\n        var bufferToSend = context.get('buffer') || [];\n\n        // Erstelle eine neue Nachricht mit dem Buffer als Payload\n        var newMsg = {\n            payload: bufferToSend\n        };\n\n        // Gib die Nachricht an den nächsten Node weiter\n        node.send(newMsg);\n\n        // Buffer und Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n\n        // Status: Versand abgeschlossen\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Success (\" + bufferToSend.length + \" entries)\" });\n\n    }, timerDelay);\n}\n\n// Diese Funktion gibt keine reguläre Nachricht weiter.\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 430,
        "y": 80,
        "wires": [
            [
                "0e88cf4f502b4eef"
            ]
        ]
    },
    {
        "id": "8d9a24255f3aa6fa",
        "type": "switch",
        "z": "10d72cae5a6340f6",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "gte",
                "v": "300",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 670,
        "y": 320,
        "wires": [
            [
                "a7fdb1fd6c1216f1"
            ],
            [
                "68d583883eeab06d"
            ]
        ]
    },
    {
        "id": "7e11d1fd34b1bb7c",
        "type": "file",
        "z": "10d72cae5a6340f6",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1020,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "a7fdb1fd6c1216f1",
        "type": "function",
        "z": "10d72cae5a6340f6",
        "name": "define file save",
        "func": "const uploaded = msg.statusCode;\nconst device_id = env.get(\"DEVICE_ID\");\n// Prüfe, ob der Upload fehlgeschlagen ist (statusCode nicht 200 oder 201)\nif (uploaded !== 200 && uploaded !== 201) {\n\n    node.status({ fill: \"red\", shape: \"ring\", text: `Upload failed with status code ${uploaded}. Saving file...` });\n\n    // Bilddaten aus dem ursprünglichen Payload holen\n    let imageData = msg.payload;\n\n    // Definiere den Speicherpfad\n    const today = new Date().toISOString().slice(0, 10);\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n    // Setze den Dateinamen im msg-Objekt\n    // Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\n    msg.filename = `/data/shared/${today}/device_${device_id}.csv`;\n\n    msg.payload = imageData;\n\n    node.status({ fill: \"green\", shape: \"ring\", text: `File saved local` });\n\n\n    // Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n    // Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\n    return msg;\n} else {\n    // Erfolgreicher Upload\n    node.status({ fill: \"green\", shape: \"dot\", text: `Upload successful with status code ${uploaded}.` });\n\n    // Gib eine leere Nachricht oder einen Erfolgs-Payload zurück, um den Flow fortzusetzen\n    msg.payload = { success: true, message: `Upload successful.` };\n\n    // Optional: Lösche das Bild, um Speicher zu sparen\n    delete msg.payload.image;\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 260,
        "wires": [
            [
                "7e11d1fd34b1bb7c"
            ]
        ]
    },
    {
        "id": "68d583883eeab06d",
        "type": "function",
        "z": "10d72cae5a6340f6",
        "name": "success",
        "func": "// Erfolgreicher Upload\nnode.status({ fill: \"green\", shape: \"dot\", text: `Upload successful` });",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "2b6eb93382b47bd0",
        "type": "status",
        "z": "57f1078111053a5e",
        "name": "",
        "scope": null,
        "x": 100,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "628e797cd0d0b7af",
        "type": "subflow:acb6954d7bc4254f",
        "z": "57f1078111053a5e",
        "name": "Image-Capture-API",
        "x": 210,
        "y": 180,
        "wires": [
            [
                "c9f2f572ea4f2a52"
            ]
        ]
    },
    {
        "id": "5bed0668634832e7",
        "type": "http request",
        "z": "57f1078111053a5e",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://onnx-runtime:8087/process-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 250,
        "y": 340,
        "wires": [
            [
                "6cc5d6df139f44bc"
            ]
        ]
    },
    {
        "id": "c9f2f572ea4f2a52",
        "type": "function",
        "z": "57f1078111053a5e",
        "name": "format to base64",
        "func": "msg.upload_url = msg.payload.upload_url\nmsg.device_id = msg.payload.device_id\n\nconst imageBytes = msg.image_base64;\n// const imageBuffer = Buffer.from(imageBytes);\n\n// const base64image = imageBuffer.toString(\"base64\");\n\n// // msg.payload = {\n// //     \"base64\": imageBytes\n// // };\n\nmsg.payload = imageBytes;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 280,
        "wires": [
            [
                "5bed0668634832e7"
            ]
        ]
    },
    {
        "id": "6cc5d6df139f44bc",
        "type": "function",
        "z": "57f1078111053a5e",
        "name": "format back",
        "func": "// Funktion zur Umwandlung eines Base64-Strings (der in einem JSON-String eingebettet ist)\n// in einen Binärdaten-Buffer.\n\n// 1. Definiere die Payload-Variable\nlet payloadData = msg.payload;\n\n// 2. Prüfe, ob die Payload ein JSON-String ist, und konvertiere sie ggf. zu einem Objekt\nif (typeof payloadData === 'string') {\n    try {\n        // Versuche, den String in ein JavaScript-Objekt zu parsen\n        payloadData = JSON.parse(payloadData);\n        // node.warn(\"JSON-String erfolgreich in Objekt geparst.\");\n    } catch (e) {\n        node.error(\"Fehler: Payload ist ein String, aber kein gültiges JSON.\", msg);\n        return null;\n    }\n}\n\n// 3. Überprüfung, ob das geparste Objekt das erwartete Format hat\nif (\n    payloadData &&\n    typeof payloadData === 'object' &&\n    payloadData.image &&\n    typeof payloadData.image === 'string'\n) {\n    const base64String = payloadData.image;\n\n    try {\n        // 4. Erstellen des Buffers aus dem Base64-String\n        const imageBuffer = Buffer.from(base64String, 'base64');\n\n        // 5. Ersetzen der Payload durch den reinen Buffer für den API-Upload\n        msg.payload = imageBuffer;\n        if (msg.upload_url) {\n            // Wenn msg.upload_url existiert und nicht leer oder null/undefined ist:\n            msg.url = msg.upload_url; // Setzt die Ziel-URL\n            msg.method = \"POST\";       // Setzt die HTTP-Methode\n\n            // Optional: Löschen der temporären upload_url, um die Nachricht aufzuräumen\n            delete msg.upload_url;\n        } else {\n            msg.url = null;\n        }\n\n        // node.warn(`Base64 zu Buffer konvertiert. Größe: ${imageBuffer.length} Bytes`);\n\n    } catch (error) {\n        // Fehlerbehandlung bei Base64-Dekodierung\n        node.error(\"Fehler beim Konvertieren des Base64-Strings in einen Buffer: \" + error.message, msg);\n        return null;\n    }\n} else {\n    // Fehler, wenn nach dem Parsen das erwartete Format nicht gefunden wurde\n    node.error(\"Fehler: Die Payload enthält nicht den erwarteten Schlüssel 'image' mit einem Base64-String.\", msg);\n    return null;\n}\n\n// Gibt die Nachricht mit dem Binärdaten-Buffer in msg.payload zurück\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 400,
        "wires": [
            [
                "026941172fca031c"
            ]
        ]
    },
    {
        "id": "555940eed7925f09",
        "type": "http request",
        "z": "57f1078111053a5e",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "body",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 310,
        "y": 520,
        "wires": [
            [
                "aee339259b081542"
            ]
        ]
    },
    {
        "id": "aee339259b081542",
        "type": "switch",
        "z": "57f1078111053a5e",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "gte",
                "v": "300",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 390,
        "y": 600,
        "wires": [
            [
                "c8f4aa89ce54e2c8"
            ],
            [
                "7a5593c178a4f132"
            ]
        ]
    },
    {
        "id": "c8f4aa89ce54e2c8",
        "type": "function",
        "z": "57f1078111053a5e",
        "name": "save local - upload failed",
        "func": "const uploaded = msg.statusCode;\nconst device_id = msg.device_id;\n\n// Prüfe, ob der Upload fehlgeschlagen ist (statusCode nicht 200 oder 201)\nif (uploaded !== 200 && uploaded !== 201) {\n\n    node.status({ fill: \"red\", shape: \"ring\", text: `Upload failed with status code ${uploaded}. Saving file...` });\n\n    // Bilddaten aus dem ursprünglichen Payload holen\n    let imageData = msg.image;\n\n    // Optional: Konvertiere das Bild in Base64, falls nötig\n    // Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n    // Ein Dateiknoten speichert Buffer direkt korrekt.\n    // Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\n    const base64Image = imageData.toString(\"base64\");\n\n    // Definiere den Speicherpfad\n    const today = new Date().toISOString().slice(0, 10);\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n    // Setze den Dateinamen im msg-Objekt\n    // Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\n    msg.filename = `/data/shared/${today}/${device_id}_${timestamp}.png`;\n\n    // Setze den Payload auf die reinen Bilddaten (als Buffer)\n    // msg.payload = imageData;\n\n    // Setze den payload auf die Bilddaten (base64)\n    msg.payload = base64Image \n\n    node.status({ fill: \"green\", shape: \"ring\", text: `File saved local` });\n\n\n    // Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n    // Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\n    return msg;\n} else {\n    // Erfolgreicher Upload\n    node.status({ fill: \"green\", shape: \"dot\", text: `Upload successful with status code ${uploaded}.` });\n\n    // Gib eine leere Nachricht oder einen Erfolgs-Payload zurück, um den Flow fortzusetzen\n    msg.payload = { success: true, message: `Upload successful for device ${device_id}.` };\n\n    // Optional: Lösche das Bild, um Speicher zu sparen\n    delete msg.payload.image;\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 560,
        "wires": [
            [
                "2a8aeb89d313a2e9"
            ]
        ]
    },
    {
        "id": "7a5593c178a4f132",
        "type": "function",
        "z": "57f1078111053a5e",
        "name": "success",
        "func": "// Erfolgreicher Upload\nnode.status({ fill: \"green\", shape: \"dot\", text: `Upload successful` });",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "2a8aeb89d313a2e9",
        "type": "file",
        "z": "57f1078111053a5e",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 800,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "026941172fca031c",
        "type": "switch",
        "z": "57f1078111053a5e",
        "name": "",
        "property": "url",
        "propertyType": "msg",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "empty"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 170,
        "y": 480,
        "wires": [
            [
                "b65ee6cc5796e60c"
            ],
            [
                "b65ee6cc5796e60c"
            ],
            [
                "555940eed7925f09"
            ]
        ]
    },
    {
        "id": "b65ee6cc5796e60c",
        "type": "function",
        "z": "57f1078111053a5e",
        "name": "save local - no url",
        "func": "const device_id = msg.opcua.device_id;\nconst timestamp = msg.opcua.timestamp;\n\nnode.status({ fill: \"red\", shape: \"ring\", text: `Upload failed. Saving file...` });\n\n// Bilddaten aus dem ursprünglichen Payload holen\nlet imageData = msg.payload;\n\n// Optional: Konvertiere das Bild in Base64, falls nötig\n// Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n// Ein Dateiknoten speichert Buffer direkt korrekt.\n// Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\nconst base64Image = imageData.toString(\"base64\");\n\n// Definiere den Speicherpfad\nconst today = new Date().toISOString().slice(0, 10);\n// const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n// Setze den Dateinamen im msg-Objekt\n// Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\nmsg.filename = `/data/shared/${today}/${device_id}_${timestamp}_onnx.png`;\n\n// Setze den Payload auf die reinen Bilddaten (als Buffer)\n// msg.payload = imageData;\n\n// Setze den payload auf die Bilddaten (base64)\nmsg.payload = base64Image\n\nnode.status({ fill: \"green\", shape: \"dot\", text: 'Saved local' });\n\n// Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n// Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 460,
        "wires": [
            [
                "6ab1902bffa66f51"
            ]
        ]
    },
    {
        "id": "6ab1902bffa66f51",
        "type": "file",
        "z": "57f1078111053a5e",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 860,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "f305719f9ecbbc1f",
        "type": "subflow:10d72cae5a6340f6",
        "z": "2dc52bb27159c699",
        "name": "Device 1 to REST",
        "env": [
            {
                "name": "URL",
                "value": "http://localhost:1880/data/readingsarray",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "30",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            }
        ],
        "x": 170,
        "y": 140,
        "wires": []
    },
    {
        "id": "b9728bcc9149f975",
        "type": "http in",
        "z": "2dc52bb27159c699",
        "name": "",
        "url": "/opc-upload",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 500,
        "wires": [
            [
                "69449903b683990a",
                "7a32b40b28e6b9d3"
            ]
        ]
    },
    {
        "id": "69449903b683990a",
        "type": "http response",
        "z": "2dc52bb27159c699",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 420,
        "y": 500,
        "wires": []
    },
    {
        "id": "7a32b40b28e6b9d3",
        "type": "debug",
        "z": "2dc52bb27159c699",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 560,
        "wires": []
    },
    {
        "id": "89652d67e89f591f",
        "type": "subflow:57f1078111053a5e",
        "z": "8af16c2e18f5774e",
        "name": "Image-Capture - API + Preprocessing",
        "x": 310,
        "y": 140,
        "wires": [
            [
                "e7172553b9751fde",
                "fb75ae543a9e53d3"
            ],
            [
                "83d0bea05bb43e10"
            ]
        ]
    },
    {
        "id": "e7172553b9751fde",
        "type": "image",
        "z": "8af16c2e18f5774e",
        "name": "Raw Image",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 650,
        "y": 140,
        "wires": []
    },
    {
        "id": "83d0bea05bb43e10",
        "type": "image",
        "z": "8af16c2e18f5774e",
        "name": "Processed Image",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 670,
        "y": 380,
        "wires": []
    },
    {
        "id": "fb75ae543a9e53d3",
        "type": "debug",
        "z": "8af16c2e18f5774e",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 80,
        "wires": []
    },
    {
        "id": "0e77e30b45d4e1b0",
        "type": "subflow:acb6954d7bc4254f",
        "z": "f783d6a195168414",
        "name": "Image-Capture-API",
        "x": 350,
        "y": 180,
        "wires": [
            [
                "c75ba9e426d4c7f6",
                "018cf589be46db49"
            ]
        ]
    },
    {
        "id": "89d54c678efd171c",
        "type": "http request",
        "z": "f783d6a195168414",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://192.168.0.166:8087/process-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "5b404c17ba0105e2"
            ]
        ]
    },
    {
        "id": "c75ba9e426d4c7f6",
        "type": "function",
        "z": "f783d6a195168414",
        "name": "format to base64",
        "func": "msg.upload_url = msg.payload.upload_url\nmsg.device_id = msg.payload.device_id\n\nconst imageBytes = msg.image_base64;\n// const imageBuffer = Buffer.from(imageBytes);\n\n// const base64image = imageBuffer.toString(\"base64\");\n\n// // msg.payload = {\n// //     \"base64\": imageBytes\n// // };\n\nmsg.payload = imageBytes;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 280,
        "wires": [
            [
                "89d54c678efd171c"
            ]
        ]
    },
    {
        "id": "5b404c17ba0105e2",
        "type": "function",
        "z": "f783d6a195168414",
        "name": "format back",
        "func": "// Funktion zur Umwandlung eines Base64-Strings (der in einem JSON-String eingebettet ist)\n// in einen Binärdaten-Buffer.\n\n// 1. Definiere die Payload-Variable\nlet payloadData = msg.payload;\n\n// 2. Prüfe, ob die Payload ein JSON-String ist, und konvertiere sie ggf. zu einem Objekt\nif (typeof payloadData === 'string') {\n    try {\n        // Versuche, den String in ein JavaScript-Objekt zu parsen\n        payloadData = JSON.parse(payloadData);\n        // node.warn(\"JSON-String erfolgreich in Objekt geparst.\");\n    } catch (e) {\n        node.error(\"Fehler: Payload ist ein String, aber kein gültiges JSON.\", msg);\n        return null;\n    }\n}\n\n// 3. Überprüfung, ob das geparste Objekt das erwartete Format hat\nif (\n    payloadData &&\n    typeof payloadData === 'object' &&\n    payloadData.image &&\n    typeof payloadData.image === 'string'\n) {\n    const base64String = payloadData.image;\n\n    try {\n        // 4. Erstellen des Buffers aus dem Base64-String\n        const imageBuffer = Buffer.from(base64String, 'base64');\n\n        // 5. Ersetzen der Payload durch den reinen Buffer für den API-Upload\n        msg.payload = imageBuffer;\n        if (msg.upload_url) {\n            // Wenn msg.upload_url existiert und nicht leer oder null/undefined ist:\n            msg.url = msg.upload_url; // Setzt die Ziel-URL\n            msg.method = \"POST\";       // Setzt die HTTP-Methode\n\n            // Optional: Löschen der temporären upload_url, um die Nachricht aufzuräumen\n            delete msg.upload_url;\n        } else {\n            msg.url = null;\n        }\n\n        // node.warn(`Base64 zu Buffer konvertiert. Größe: ${imageBuffer.length} Bytes`);\n\n    } catch (error) {\n        // Fehlerbehandlung bei Base64-Dekodierung\n        node.error(\"Fehler beim Konvertieren des Base64-Strings in einen Buffer: \" + error.message, msg);\n        return null;\n    }\n} else {\n    // Fehler, wenn nach dem Parsen das erwartete Format nicht gefunden wurde\n    node.error(\"Fehler: Die Payload enthält nicht den erwarteten Schlüssel 'image' mit einem Base64-String.\", msg);\n    return null;\n}\n\n// Gibt die Nachricht mit dem Binärdaten-Buffer in msg.payload zurück\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 400,
        "wires": [
            [
                "139839c1527dd1d8",
                "f4737a7c213382e7"
            ]
        ]
    },
    {
        "id": "3693a03152a2ac6c",
        "type": "http request",
        "z": "f783d6a195168414",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "body",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 450,
        "y": 520,
        "wires": [
            [
                "fa0753bca263ca22"
            ]
        ]
    },
    {
        "id": "fa0753bca263ca22",
        "type": "switch",
        "z": "f783d6a195168414",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "gte",
                "v": "300",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 530,
        "y": 600,
        "wires": [
            [
                "ba96cbdc449355be"
            ],
            [
                "9f223ff6f5918e7b"
            ]
        ]
    },
    {
        "id": "ba96cbdc449355be",
        "type": "function",
        "z": "f783d6a195168414",
        "name": "save local - upload failed",
        "func": "const uploaded = msg.statusCode;\nconst device_id = msg.device_id;\n\n// Prüfe, ob der Upload fehlgeschlagen ist (statusCode nicht 200 oder 201)\nif (uploaded !== 200 && uploaded !== 201) {\n\n    node.status({ fill: \"red\", shape: \"ring\", text: `Upload failed with status code ${uploaded}. Saving file...` });\n\n    // Bilddaten aus dem ursprünglichen Payload holen\n    let imageData = msg.image;\n\n    // Optional: Konvertiere das Bild in Base64, falls nötig\n    // Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n    // Ein Dateiknoten speichert Buffer direkt korrekt.\n    // Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\n    const base64Image = imageData.toString(\"base64\");\n\n    // Definiere den Speicherpfad\n    const today = new Date().toISOString().slice(0, 10);\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n    // Setze den Dateinamen im msg-Objekt\n    // Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\n    msg.filename = `/data/shared/${today}/${device_id}_${timestamp}.png`;\n\n    // Setze den Payload auf die reinen Bilddaten (als Buffer)\n    // msg.payload = imageData;\n\n    // Setze den payload auf die Bilddaten (base64)\n    msg.payload = base64Image \n\n    node.status({ fill: \"green\", shape: \"ring\", text: `File saved local` });\n\n\n    // Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n    // Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\n    return msg;\n} else {\n    // Erfolgreicher Upload\n    node.status({ fill: \"green\", shape: \"dot\", text: `Upload successful with status code ${uploaded}.` });\n\n    // Gib eine leere Nachricht oder einen Erfolgs-Payload zurück, um den Flow fortzusetzen\n    msg.payload = { success: true, message: `Upload successful for device ${device_id}.` };\n\n    // Optional: Lösche das Bild, um Speicher zu sparen\n    delete msg.payload.image;\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 560,
        "wires": [
            [
                "0a9b8c943678ee02"
            ]
        ]
    },
    {
        "id": "9f223ff6f5918e7b",
        "type": "function",
        "z": "f783d6a195168414",
        "name": "success",
        "func": "// Erfolgreicher Upload\nnode.status({ fill: \"green\", shape: \"dot\", text: `Upload successful` });",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "0a9b8c943678ee02",
        "type": "file",
        "z": "f783d6a195168414",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 940,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "139839c1527dd1d8",
        "type": "switch",
        "z": "f783d6a195168414",
        "name": "",
        "property": "url",
        "propertyType": "msg",
        "rules": [
            {
                "t": "null"
            },
            {
                "t": "empty"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 310,
        "y": 480,
        "wires": [
            [
                "de71763421cb7072"
            ],
            [
                "de71763421cb7072"
            ],
            [
                "3693a03152a2ac6c"
            ]
        ]
    },
    {
        "id": "de71763421cb7072",
        "type": "function",
        "z": "f783d6a195168414",
        "name": "save local - no url",
        "func": "const device_id = msg.opcua.device_id;\nconst timestamp = msg.opcua.timestamp;\n\nnode.status({ fill: \"red\", shape: \"ring\", text: `Upload failed. Saving file...` });\n\n// Bilddaten aus dem ursprünglichen Payload holen\nlet imageData = msg.payload;\n\n// Optional: Konvertiere das Bild in Base64, falls nötig\n// Wenn das Bild bereits als Buffer vorliegt, ist eine Konvertierung nicht notwendig.\n// Ein Dateiknoten speichert Buffer direkt korrekt.\n// Falls du es als Base64-String benötigst, kannst du es hier konvertieren:\nconst base64Image = imageData.toString(\"base64\");\n\n// Definiere den Speicherpfad\nconst today = new Date().toISOString().slice(0, 10);\n// const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n\n// Setze den Dateinamen im msg-Objekt\n// Der Dateiname sollte den vollständigen Pfad enthalten, damit das 'file'-Node weiß, wohin es speichern soll.\nmsg.filename = `/data/shared/${today}/${device_id}_${timestamp}_onnx.png`;\n\n// Setze den Payload auf die reinen Bilddaten (als Buffer)\n// msg.payload = imageData;\n\n// Setze den payload auf die Bilddaten (base64)\nmsg.payload = base64Image\n\nnode.status({ fill: \"green\", shape: \"dot\", text: 'Saved local' });\n\n// Wichtiger Hinweis: Setze den `msg.filename` und `msg.payload` und gib `msg` zurück.\n// Das `file`-Node wird diese Eigenschaften verwenden, um die Datei zu speichern.\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 460,
        "wires": [
            [
                "fd0b77b22e864f03"
            ]
        ]
    },
    {
        "id": "fd0b77b22e864f03",
        "type": "file",
        "z": "f783d6a195168414",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "base64",
        "x": 1000,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "018cf589be46db49",
        "type": "image",
        "z": "f783d6a195168414",
        "name": "",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 860,
        "y": 120,
        "wires": []
    },
    {
        "id": "f4737a7c213382e7",
        "type": "image",
        "z": "f783d6a195168414",
        "name": "",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 1060,
        "y": 140,
        "wires": []
    }
]