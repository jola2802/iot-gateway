[
    {
        "id": "4071c101bbc3e907",
        "type": "tab",
        "label": "Data Forwarding",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e129ee69a298a464",
        "type": "tab",
        "label": "Image-Capture",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e7b0b0bc76ad7903",
        "type": "tab",
        "label": "Image-Upload",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4438aad0eeb0b771",
        "type": "tab",
        "label": "testing",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "b784f457619f1095",
        "type": "subflow",
        "name": "MQTT to REST",
        "info": "### **MQTT to REST Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **MQTT to REST**-Subflow sammelt kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten als JSON per HTTP POST an einen definierten REST API Endpoint versendet. Dabei gibt die Node Statusmeldungen (z. B. Buffergröße, Versandstatus) über den zweiten Ausgang zur Prozessüberwachung aus.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand ihres Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, einen **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gespeichert.\r\n\r\n2. **Zeitbasierter Versand:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (sec)`, steuert den Zeitpunkt des Datenversands.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Buffer als JSON serialisiert und per HTTP POST an den konfigurierten REST API Endpoint gesendet.\r\n\r\n3. **HTTP-Versand:**  \r\n   - Die Node erstellt aus dem Buffer den POST-Datenstring und sendet diesen unter Verwendung der konfigurierten HTTP-Header.  \r\n   - Der REST API Endpoint wird in der Umgebungsvariablen `URL` definiert.\r\n\r\n4. **Statusüberwachung:**  \r\n   - Über den zweiten Ausgang werden Statusmeldungen zur aktuellen Buffergröße und zum Versandstatus ausgegeben.\r\n\r\n#### **Beispiel für den Datenversand:**  \r\nAngenommen, der Buffer enthält zwei Datenpunkte, könnte das an den REST API Endpoint gesendete JSON-Dokument wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 22.5,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 45,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses JSON wird mittels HTTP POST an den in `URL` definierten Endpoint versendet. Die HTTP-Header, beispielsweise `{\"Content-Type\": \"application/json\"}`, werden ebenfalls mitgeschickt.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable             | Typ        | Standardwert                                              | Beschreibung |\r\n|----------------------|------------|-----------------------------------------------------------|--------------|\r\n| `URL`                | String     | `\"https://url.com\"`                                       | REST API Endpoint für den HTTP POST Versand |\r\n| `HEADER`             | JSON       | `{\"Content-Type\":\"application/json\"}`                     | HTTP-Header, die beim Versand genutzt werden |\r\n| `INTERVAL (sec)`     | Num        | `60`                                                      | Zeitintervall (in Sekunden) nach dem der Buffer versendet wird |\r\n| `BROKER`             | MQTT-Broker| -                                                         | Verknüpfung zum MQTT-Broker |\r\n| `TOPIC`              | String     | `\"data/opc-ua/1/#\"`                                        | MQTT-Topic, über das die Daten empfangen werden |\r\n| `DEVICEID`           | String     | `\"1\"`                                                     | Gerätebezeichnung, die bei der Datenaggregation berücksichtigt wird |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und Weiterleitung von MQTT-Daten an REST-basierte Anwendungen  \r\n✔ Integration in IoT-Datenpipelines zur zentralen Verarbeitung und Speicherung von Sensordaten  \r\n✔ Überwachung und Statusprotokollierung der Datenübertragung zur Fehlerdiagnose  \r\n",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "URL",
                "type": "str",
                "value": "https://url.com",
                "ui": {
                    "icon": "font-awesome/fa-plug",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{\"Content-Type\":\"application/json\"}",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/opc-ua/1/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect Data & Send to REST"
        },
        "color": "#3FADB5",
        "icon": "font-awesome/fa-map-signs",
        "status": {
            "x": 460,
            "y": 20,
            "wires": [
                {
                    "id": "fb4b6772875e2106",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "2a3d9e44553dfac0",
        "type": "subflow",
        "name": "Collect & Save in File",
        "info": "### **Collect & Save in File Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **Collect & Save in File**-Subflow aggregiert kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten in einem definierten Verzeichnis abgelegt. Dabei unterstützt die Node verschiedene Dateiformate (**JSON**, **CSV** oder **XML**) sowie zwei Modi: Das **Anhängen** an eine bestehende Datei oder das **Erstellen** einer neuen Datei mit Zeitstempel. Statusmeldungen zur aktuellen Buffergröße und dem Speichervorgang werden über den zweiten Ausgang ausgegeben.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand des Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, den **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gesammelt.\r\n\r\n2. **Zeitbasierte Speicherung:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (MS)`, steuert den Zeitpunkt der Speicherung.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Bufferinhalt ausgelesen und in eine Datei geschrieben.\r\n\r\n3. **Dateiformat und Schreibmodus:**  \r\n   - Das Dateiformat (JSON, CSV oder XML) wird über die Umgebungsvariable `FORMAT` festgelegt.  \r\n   - Über den Modus (`MODE`) kann festgelegt werden, ob Daten an eine bestehende Datei angehängt („append“) oder in einer neuen Datei mit Zeitstempel abgelegt werden („new“).  \r\n   - Der Basis-Dateiname wird über die Umgebungsvariable `FILENAME` definiert.\r\n\r\n4. **Verzeichnisverwaltung und Status-Updates:**  \r\n   - Das Zielverzeichnis wird (falls notwendig) automatisch erstellt.  \r\n   - Während des gesamten Prozesses werden Statusmeldungen ausgegeben, die den aktuellen Bufferinhalt sowie den Erfolg des Schreibvorgangs dokumentieren.\r\n\r\n#### **Beispiel für einen gespeicherten Dateiinhalt (im JSON-Format):**  \r\nAngenommen, der Buffer enthält drei Datenpunkte, könnte der Inhalt der gespeicherten Datei wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 21.7,\r\n    \"Timestamp\": \"2023-03-01T10:15:30.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 48,\r\n    \"Timestamp\": \"2023-03-01T10:15:35.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"pressure\",\r\n    \"Value\": 1013,\r\n    \"Timestamp\": \"2023-03-01T10:15:40.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses Beispiel zeigt, wie die Datenpunkte im JSON-Format strukturiert werden. Ähnliche Beispiele können für CSV oder XML erzeugt werden, wobei CSV z. B. wie folgt aussehen könnte:\r\n\r\n```\r\nDatapointId,Value,Timestamp\r\ntemperature,21.7,2023-03-01T10:15:30.000Z\r\nhumidity,48,2023-03-01T10:15:35.000Z\r\npressure,1013,2023-03-01T10:15:40.000Z\r\n```\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable           | Typ            | Standardwert           | Beschreibung                                                   |\r\n|--------------------|----------------|------------------------|----------------------------------------------------------------|\r\n| `PATH`             | String         | `/data`                | Verzeichnis, in dem die Datei gespeichert wird                 |\r\n| `FORMAT`           | String         | `json`                 | Dateiformat: JSON, CSV oder XML                                |\r\n| `MODE`             | String         | `new`                  | Schreibmodus: „append“ oder „new“                              |\r\n| `FILENAME`         | String         | (leer)                 | Basis-Dateiname für die Speicherung                          |\r\n| `INTERVAL (sec)`   | Num            | `60`                   | Speichervorgang-Intervall in Sekunden (wird zur Anzeige genutzt)|\r\n| `INTERVAL (MS)`    | Num            | `60000`                | Speichervorgang-Intervall in Millisekunden                     |\r\n| `BROKER`           | MQTT-Broker    | -                      | Verknüpfung zum MQTT-Broker                                    |\r\n| `TOPIC`            | String         | `data/#`               | MQTT-Topic, über das Daten empfangen werden                    |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und persistente Speicherung von Zeitreihendaten aus MQTT-Streams  \r\n✔ Erstellung von Datenexporten für spätere Analysen oder externe Systeme  \r\n✔ Flexible Speicherung in verschiedenen Formaten und Modi (Anhängen oder neu erstellen)  \r\n",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "PATH",
                "type": "str",
                "value": "/data",
                "ui": {
                    "icon": "font-awesome/fa-file-text-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "json",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            },
            {
                "name": "MODE",
                "type": "str",
                "value": "new",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect & Save in File"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 480,
            "y": 20,
            "wires": [
                {
                    "id": "a101bcd063f6e0e4",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "dac356dc77e3d814",
        "type": "subflow",
        "name": "Image-Capture-Process-NODE-RED",
        "info": "# Image Capture Process\r\n\r\nThis subflow implements a complete image capture process using OPC UA and is designed to perform all the steps required for the process in a single, consolidated flow. In detail, the subflow includes:\r\n\r\n## Connection setup and security configuration:\r\nAn OPC UA client is created that connects to an OPC UA server based on passed or environment variables (e.g. endpoint, security mode/policy, username and password).\r\n\r\n## Method call and process control:\r\nThe subflow calls a specified method on the server to initiate the image capture process. It then actively waits for a defined Boolean status (check node) to change in order to determine the right time for image processing.\r\n\r\n## Acknowledgement and optional upload:\r\nAfter successful saving, an acknowledge (Ack) is written back to the server. An HTTP POST upload of the saved file to a defined target endpoint is optional. Finally, the subflow returns a payload object with detailed information about the process, such as success message, security parameters used, storage path and the image string.\r\n\r\n## Important note:\r\nThis subflow is designed as a central component and **only needs to be implemented once in the entire Node-RED instance**. This ensures that all image acquisition processes are controlled consistently and centrally, resulting in optimized resource usage and a clear architecture.\r\n",
        "category": "Image-Capture",
        "in": [
            {
                "x": 280,
                "y": 440,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 680,
                "y": 440,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "IN_ENDPOINT",
                "type": "str",
                "value": "/opc-image",
                "ui": {
                    "icon": "font-awesome/fa-chain",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#C0C0C0",
        "icon": "font-awesome/fa-exclamation",
        "status": {
            "x": 600,
            "y": 40,
            "wires": [
                {
                    "id": "7305073267fb70ed",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "a83312e9e2e175ac",
        "type": "subflow",
        "name": "Img-Cap-Process-Backend",
        "info": "### **Img-Cap-Process-Backend Node**  \r\n#### **Kategorie:** Image-Capture  \r\n#### **Beschreibung:**  \r\nDer **Img-Cap-Process-Backend**-Subflow sammelt alle für den Bildaufnahmeprozess relevanten Parameter – wie OPC UA Verbindungsdaten, Methoden- und Node-IDs, Sicherheitsparameter sowie Upload-Konfigurationen – und leitet diese in Form einer strukturierten Payload an ein vordefiniertes Go-Backend weiter. Dort wird der eigentliche Bildaufnahme- und Verarbeitungsprozess durchgeführt.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Parameter-Sammlung:**  \r\n   - Der Subflow liest sämtliche Konfigurationsparameter entweder aus den Umgebungsvariablen oder aus der eingehenden Nachricht aus.  \r\n   - Dazu zählen unter anderem der OPC UA Endpoint, die zu verwendenden Methoden- und Node-IDs sowie die Sicherheitsparameter (Security Mode/Policy, Benutzername, Passwort).\r\n\r\n2. **Payload-Erstellung:**  \r\n   - Alle gesammelten Parameter werden in ein JSON-Objekt überführt, das alle erforderlichen Informationen für den Bildaufnahmeprozess enthält.\r\n\r\n3. **Weiterleitung an das Go-Backend:**  \r\n   - Das JSON-Payload wird per HTTP POST an eine konfigurierte Backend-URL gesendet.  \r\n   - Das Go-Backend übernimmt daraufhin den kompletten Bildaufnahmeprozess und liefert als Antwort den entsprechenden Verarbeitungsstatus zurück.\r\n\r\n4. **Ergebnisrückgabe:**  \r\n   - Das Ergebnis (z. B. Erfolgsmeldung, Bilddaten, Metainformationen) wird an den weiteren Flow zurückgegeben.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable           | Typ   | Standardwert                                    | Beschreibung |\r\n|--------------------|-------|-------------------------------------------------|--------------|\r\n| `OPC_ENDPOINT`     | String| `\"opc.tcp://192.168.0.84:48010\"`                  | OPC UA Server Endpoint |\r\n| `OPC_SEC_MODE`     | String| `\"NONE\"`                                        | Sicherheitsmodus (z. B. NONE, SIGN, SIGNANDENCRYPT) |\r\n| `OPC_SEC_POLICY`   | String| `\"NONE\"`                                        | Sicherheits-Policy (z. B. BASIC128RSA15, BASIC256, BASIC256SHA256) |\r\n| `OPC_USER`         | String| `\"\"`                                            | Benutzername für OPC UA (optional) |\r\n| `OPC_PW`           | String| `\"\"`                                            | Passwort für OPC UA (optional) |\r\n| `M_NODE_PARENT`    | String| `\"ns=3;s=Demo.Method\"`                           | Objekt-ID der OPC UA Methode |\r\n| `M_NODE_IMAGE`     | String| `\"ns=3;s=Demo.Method.Multiply\"`                  | Methoden-ID bzw. Node-ID, die den Bildaufnahmeprozess triggert |\r\n| `M_ARGS`           | JSON  | `{\"a\":\"5\",\"b\":\"11\"}`                             | Parameter für die Methode (im JSON-Format) |\r\n| `NODE_CHECK`       | String| `\"ns=3;s=Demo.Dynamic.Scalar.Boolean\"`           | Node-ID, die den Status (Boolean) überwacht |\r\n| `NODE_IMAGE`       | String| `\"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\"`          | Node-ID, von der der Bildstring ausgelesen wird |\r\n| `NODE_ACK_READ`    | String| `\"ns=3;s=Demo.Dynamic.Scalar.Boolean\"`           | Node-ID, in die das ACK geschrieben wird |\r\n| `BASEPATH`         | String| `\"\"`                                            | Basis-Pfad für lokale Speicherung (nicht aktiv genutzt) |\r\n| `DEVICE_ID`        | String| `\"\"`                                            | Geräte-/Unterordner-Bezeichnung (wird an das Backend übermittelt) |\r\n| `ENABLE_UPLOAD`    | String| `\"true\"`                                        | Aktivierung des Uploads (`\"true\"` oder `\"false\"`) |\r\n| `UPLOAD_URL`       | String| `\"https://192.168.0.84/nodered/opc-upload\"`       | URL für den optionalen Upload der Bilddaten |\r\n| `HEADERS`          | JSON  | `{\"Content-Type\":\"application/octet-stream\"}`   | Zusätzliche HTTP-Header für den Upload |\r\n| `BACKEND_URL`      | String| `\"http://iot-gateway:8088/api/img-process\"`       | URL des Go-Backends, das den Bildaufnahmeprozess umsetzt |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Zentrale Steuerung der Bildaufnahmeprozesse, indem lediglich die notwendigen Parameter an ein spezialisiertes Backend weitergereicht werden.  \r\n✔ Entlastung des Node-RED-Systems durch Auslagerung der Bildverarbeitung an ein dediziertes Go-Backend.  \r\n✔ Einheitliche und skalierbare Implementierung des Bildaufnahmeprozesses innerhalb der gesamten Node-RED-Instanz.  ",
        "category": "Image-Capture",
        "in": [
            {
                "x": 240,
                "y": 100,
                "wires": [
                    {
                        "id": "92f6fd0436ca3513"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 910,
                "y": 100,
                "wires": [
                    {
                        "id": "92f6fd0436ca3513",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "OPC_ENDPOINT",
                "type": "str",
                "value": "opc.tcp://192.168.0.84:48010",
                "ui": {
                    "icon": "font-awesome/fa-location-arrow",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "OPC_SEC_MODE",
                "type": "str",
                "value": "NONE",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "type": "hide"
                }
            },
            {
                "name": "OPC_SEC_POLICY",
                "type": "str",
                "value": "NONE",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "type": "hide"
                }
            },
            {
                "name": "OPC_USER",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-address-book-o",
                    "type": "hide"
                }
            },
            {
                "name": "OPC_PW",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-lock",
                    "type": "hide"
                }
            },
            {
                "name": "M_NODE_PARENT",
                "type": "str",
                "value": "ns=3;s=Demo.Method",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Method.Multiply",
                "ui": {
                    "icon": "font-awesome/fa-camera",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "M_ARGS",
                "type": "json",
                "value": "{\"a\":\"5\",\"b\":\"11\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "NODE_CHECK",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "icon": "font-awesome/fa-check-circle-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.ImageGIF",
                "ui": {
                    "icon": "font-awesome/fa-image",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "NODE_ACK_READ",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "BASEPATH",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "hide"
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "hide"
                }
            },
            {
                "name": "ENABLE_UPLOAD",
                "type": "str",
                "value": "true",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "true"
                                },
                                "v": "true"
                            },
                            {
                                "l": {
                                    "de": "false"
                                },
                                "v": "false"
                            }
                        ]
                    }
                }
            },
            {
                "name": "UPLOAD_URL",
                "type": "str",
                "value": "https://192.168.0.84/nodered/opc-upload",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADERS",
                "type": "json",
                "value": "{\"Content-Type\":\"application/octet-stream\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "node-red-contrib-opc-image-capture",
            "type": "opc-image-capture",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "A node to grab images from an opc-ua server.",
            "keywords": "opc-ua, gateway",
            "license": "Apache-2.0"
        },
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "image"
        ],
        "icon": "font-awesome/fa-camera-retro",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "0b0d19296544b9f8",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ef4290a715908540",
        "type": "subflow",
        "name": "InfluxDB to REST",
        "info": "### **InfluxDB-to-REST Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **InfluxDB-to-REST**-Subflow ermöglicht das periodische Abrufen von Daten aus einer **InfluxDB**-Datenbank und sendet diese per **HTTP-POST** an eine definierte **REST-API**.  \r\nDie Node erlaubt eine flexible Konfiguration der **Ziel-URL**, **HTTP-Header** und **Abfrageintervalle**.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Abfrageerstellung:**  \r\n   - Die Node generiert eine **Flux-Query**, um die letzten *n* Sekunden aus der InfluxDB abzufragen.  \r\n   - Der Zeitbereich kann über die Umgebungsvariable `TIMER (sec)` konfiguriert werden.  \r\n   - Der Filter basiert auf der `DEVICE_ID`, um gerätespezifische Daten zu extrahieren.  \r\n\r\n2. **Datenabruf:**  \r\n   - Die generierte Flux-Query wird an die InfluxDB gesendet.  \r\n   - Die abgerufenen Daten werden als JSON-Objekt weitergeleitet.  \r\n\r\n3. **Datenversand:**  \r\n   - Die abgerufenen Daten werden per **HTTP-POST** an den konfigurierten **REST-API-Endpoint** gesendet.  \r\n   - Die Ziel-URL und HTTP-Header können über die Umgebungsvariablen `URL` und `HEADER` definiert werden.  \r\n\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusmeldungen zur Laufzeitdauer und Anzahl der gesendeten Datensätze ausgegeben.  \r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable       | Typ       | Standardwert | Beschreibung |  \r\n|---------------|----------|-------------|-------------|  \r\n| `INFLUXDB`    | InfluxDB | -           | Verknüpfung zur InfluxDB-Instanz |  \r\n| `URL`         | String   | `\"http://192.168.0.84:4999\"` | Ziel-URL für den REST-Request |  \r\n| `HEADER`      | JSON     | `{}`        | Zusätzliche HTTP-Header im JSON-Format |  \r\n| `DEVICE_ID`   | String   | `1`         | ID des Geräts, dessen Daten abgefragt werden |  \r\n| `TIMER (sec)` | String   | `10`        | Zeitintervall für die Datenabfrage (in Sekunden) |  \r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Automatische Übertragung von Sensordaten aus InfluxDB an REST-APIs  \r\n✔ Integration in IoT-Datenpipelines für Cloud- und Edge-Anwendungen  \r\n✔ Datensynchronisation mit externen Datenplattformen  ",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "498350a0e7d7fa21"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "INFLUXDB",
                "type": "influxdb",
                "value": "a1403f82a270e6f4",
                "ui": {
                    "type": "conf-types"
                }
            },
            {
                "name": "URL",
                "type": "str",
                "value": "http://192.168.0.84:4999"
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{}"
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1"
            },
            {
                "name": "TIMER (sec)",
                "type": "str",
                "value": "10"
            }
        ],
        "meta": {},
        "color": "#3FADB5",
        "icon": "node-red/leveldb.svg",
        "status": {
            "x": 380,
            "y": 20,
            "wires": [
                {
                    "id": "16c9290388d72e82",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "f5c5556a9e4eb0ae",
        "type": "subflow",
        "name": "Influx-to-File",
        "info": "### **Influx-to-File Node**\r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **Influx-to-File**-Subflow ermöglicht das periodische Abrufen von Daten aus einer **InfluxDB**-Datenbank und speichert diese in einer Datei. Die Daten können in den Formaten **JSON, CSV oder XML** gespeichert werden.  \r\nDie Node unterstützt sowohl das **Anhängen** an bestehende Dateien als auch das **Erstellen** neuer Dateien mit einem Zeitstempel.  \r\n\r\n#### **Funktionsweise:**\r\n1. **Abfrageerstellung:**  \r\n   - Die Node generiert eine **Flux-Query**, um die letzten *n* Sekunden aus der InfluxDB abzufragen.  \r\n   - Der Zeitbereich kann über die Umgebungsvariable `TIMER (sec)` konfiguriert werden.  \r\n   - Der Filter basiert auf der `DEVICE_ID`, um gerätespezifische Daten zu extrahieren.\r\n\r\n2. **Datenabruf:**  \r\n   - Die generierte Flux-Query wird an die InfluxDB gesendet.  \r\n   - Die abgerufenen Daten werden als JSON-Objekt weitergeleitet.  \r\n\r\n3. **Dateispeicherung:**  \r\n   - Die Daten werden im angegebenen `FILE_PATH` als JSON, CSV oder XML gespeichert.  \r\n   - Falls der Speicherpfad nicht existiert, wird er automatisch erstellt.  \r\n   - Bestehende Dateien können überschrieben (`new`) oder ergänzt (`append`) werden.  \r\n\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusmeldungen zur Laufzeitdauer und Anzahl der gespeicherten Datensätze ausgegeben.  \r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**\r\n| Variable       | Typ       | Standardwert | Beschreibung |\r\n|---------------|----------|-------------|-------------|\r\n| `INFLUXDB`    | InfluxDB | -           | Verknüpfung zur InfluxDB-Instanz |\r\n| `FILE_PATH`   | String   | `/data`     | Verzeichnis, in dem die Datei gespeichert wird |\r\n| `DEVICE_ID`   | String   | `1`         | ID des Geräts, dessen Daten abgefragt werden |\r\n| `TIMER (sec)` | String   | `1`         | Zeitintervall für die Datenabfrage (in Sekunden) |\r\n\r\n#### **Einsatzmöglichkeiten:**\r\n✔ Speicherung von Zeitreihenmesswerten aus einer InfluxDB  \r\n✔ Erstellung von Datenexporten für externe Systeme  \r\n✔ Regelmäßige Datensicherung oder Analysezwecke  ",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "4a16a8db342b7323"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "INFLUXDB",
                "type": "influxdb",
                "value": "a1403f82a270e6f4",
                "ui": {
                    "type": "conf-types"
                }
            },
            {
                "name": "FILE_PATH",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER (sec)",
                "type": "str",
                "value": "1"
            }
        ],
        "meta": {},
        "color": "#3FADB5",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "71c0dcf56b57e3e9",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "0e108f67fce9da41",
        "type": "group",
        "z": "dac356dc77e3d814",
        "name": "OPC-Image-Capture",
        "style": {
            "fill": "#d1d1d1",
            "label": true,
            "label-position": "n",
            "color": "#000000"
        },
        "nodes": [
            "a348ffb0a5633da2",
            "f8828b8e3af04a58",
            "b96815da0497ae16",
            "842b6ef57c490524"
        ],
        "x": 314,
        "y": 119,
        "w": 312,
        "h": 282
    },
    {
        "id": "699ee5c1c3dc383e",
        "type": "group",
        "z": "e7b0b0bc76ad7903",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "cb83d0b9bbc23ce4",
            "22f3e072ed258a2f",
            "0dc25daa4866e6e4",
            "b43ada02cf576d59",
            "cf032448930f65c9"
        ],
        "x": 74,
        "y": 79,
        "w": 632,
        "h": 202
    },
    {
        "id": "4fa0c14be559bdb6",
        "type": "group",
        "z": "e7b0b0bc76ad7903",
        "name": "publish data to existing device",
        "style": {
            "label": true
        },
        "nodes": [
            "981c7a177fa98054",
            "6d52b6f1c958ee82",
            "5bfc5c4ac52ffcec"
        ],
        "x": 154,
        "y": 379,
        "w": 512,
        "h": 182
    },
    {
        "id": "d1d25278780d0bb3",
        "type": "global-config",
        "name": "global-config",
        "env": [
            {
                "name": "influx-token",
                "value": "secret-token",
                "type": "str"
            }
        ]
    },
    {
        "id": "e82a7202f23f3cdd",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "0b7c7515b1c6aa53",
        "type": "mqtt-broker",
        "name": "",
        "broker": "iot-gateway",
        "port": "5000",
        "tls": "e82a7202f23f3cdd",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "3",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a1403f82a270e6f4",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx-gateway",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "5007a50a62dcb950",
        "type": "s7 endpoint",
        "transport": "iso-on-tcp",
        "address": "192.168.0.84",
        "port": "1102",
        "rack": "0",
        "slot": "2",
        "localtsaphi": "01",
        "localtsaplo": "00",
        "remotetsaphi": "01",
        "remotetsaplo": "00",
        "connmode": "rack-slot",
        "adapter": "",
        "busaddr": 2,
        "cycletime": "600",
        "timeout": 2000,
        "name": "",
        "vartable": [
            {
                "addr": "I0.0",
                "name": "Input_Bool_1"
            },
            {
                "addr": "QI20",
                "name": "Output_Num_1"
            }
        ]
    },
    {
        "id": "e814f02eb2484f60",
        "type": "function",
        "z": "b784f457619f1095",
        "name": "collect & send data REST",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Versand mit Statusanzeige\n *\n * - Alle eingehenden Nachrichten werden als Datenpunkte in einem Buffer gespeichert.\n * - Nach Ablauf des konfigurierten Zeitintervalls (config.timerDelay oder msg.timerDelay) wird\n *   der Buffer per HTTP POST an den definierten Endpoint (config.endpoint oder msg.endpoint)\n *   versendet.\n * - Die HTTP-Header können ebenfalls per msg.headers überschrieben werden.\n * - Statusmeldungen werden ausschließlich über node.status() ausgegeben.\n */\n\n// Konfiguration\nvar config = {\n    topicSeparator: '/'\n};\n\n// Übernehmen der Konfiguration aus Umgebungsvariablen\nvar timerDelay = env.get(\"INTERVAL (sec)\") * 1000;\nvar endpoint   = env.get(\"URL\");\nvar headers    = env.get(\"HEADER\");\nvar topic      = env.get(\"TOPIC\");\n\n// ------------------------------\n// Hilfsfunktion zur Status-Aktualisierung (nur node.status)\n// ------------------------------\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n}\n\n// ==============================\n// Datenpunkt erfassen und in den Buffer einfügen\n// ==============================\nvar buffer = context.get('buffer') || [];\n\n// Extrahiere das letzte, nicht-leere Segment aus msg.topic als Datenpunkt-ID\nvar topicParts = msg.topic.split(config.topicSeparator).filter(function (part) {\n    return part !== '';\n});\nvar datapointId = topicParts[topicParts.length - 1];\n\n// Erstelle einen neuen Datenpunkt-Eintrag\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()  // ISO 8601 Zeitstempel\n};\n\n// Füge den Datenpunkt dem Buffer hinzu\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n\n// Status: Sammeln\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// ==============================\n// Timer-Logik: Versand des Buffers nach timerDelay, falls nicht bereits gesetzt\n// ==============================\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    setTimeout(function () {\n        // Status: Sende Daten...\n        updateStatus(\"Send Data ...\", \"yellow\", \"ring\");\n\n        // Lese den aktuell gespeicherten Buffer\n        var bufferToSend = context.get('buffer') || [];\n\n        // Erstelle den POST-Datenstring\n        var postData = JSON.stringify(bufferToSend);\n\n        // Zerlege den Endpoint in seine Bestandteile\n        var endpointUrl = url.parse(endpoint);\n        var options = {\n            hostname: endpointUrl.hostname,\n            port: endpointUrl.port,\n            path: endpointUrl.path,\n            method: 'POST',\n            headers: Object.assign({}, headers, {\n                'Content-Length': Buffer.byteLength(postData)\n            })\n        };\n\n        // Initialisiere den HTTP POST Request\n        var req = http.request(options, function (res) {\n            var responseBody = \"\";\n            res.setEncoding('utf8');\n            res.on('data', function (chunk) {\n                responseBody += chunk;\n            });\n            res.on('end', function () {\n                // node.log(\"HTTP POST response: \" + responseBody);\n                // Status: Versand abgeschlossen\n                updateStatus(\"Success Upload (\" + bufferToSend.length + \" Einträge)\", \"green\", \"dot\");\n            });\n        });\n\n        req.on('error', function (e) {\n            node.error(\"HTTP POST request error: \" + e.message);\n            updateStatus(\"Error sending data\", \"red\", \"ring\");\n        });\n\n        req.write(postData);\n        req.end();\n\n        // Buffer und Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n    }, timerDelay);\n}\n\n// Diese Funktion gibt keine reguläre Nachricht weiter.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 370,
        "y": 80,
        "wires": []
    },
    {
        "id": "b8ab04611540d0c6",
        "type": "mqtt in",
        "z": "b784f457619f1095",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "e814f02eb2484f60"
            ]
        ]
    },
    {
        "id": "fb4b6772875e2106",
        "type": "status",
        "z": "b784f457619f1095",
        "name": "",
        "scope": null,
        "x": 320,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "424f5da4789c7d8e",
        "type": "function",
        "z": "2a3d9e44553dfac0",
        "name": "collect & save in file",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Speicherung in einer Datei\n *\n * - Daten werden in einem Buffer gesammelt und nach einer bestimmten Zeit gespeichert.\n * - Speicherung in einer Datei als JSON, XML oder CSV.\n * - Möglichkeit, entweder eine Datei kontinuierlich zu erweitern oder eine neue Datei für jede Speicherung zu erstellen.\n */\n\n// -----------------------------------------------\n// 1) Subflow-Variablen aus Umgebungsvariablen\n// -----------------------------------------------\nvar config = {\n    topicSeparator: '/',\n    intervalMs: parseInt(env.get(\"INTERVAL (MS)\")) || 60000,   // Fallback: 60s\n    filePath: env.get(\"PATH\") || \"/data\",                         // Standardpfad\n    fileFormat: (env.get(\"FORMAT\") || \"json\").toLowerCase(),      // json, xml, csv\n    fileMode: (env.get(\"MODE\") || \"new\").toLowerCase(),           // \"append\" oder \"new\"\n    fileName: env.get(\"FILENAME\") || \"data\"                       // Basis-Dateiname für beide Modi\n};\n// node.log(\"Konfiguration geladen: \" + JSON.stringify(config));\n\n// -----------------------------------------------\n// 2) Hilfsfunktionen\n// -----------------------------------------------\n\nfunction formatTimestamp(date) {\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n/** Aktualisiert den Node-Status (ohne Subflow-Ausgang) */\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n    // node.log(\"Status aktualisiert: \" + statusMsg);\n}\n\n/** Erzeugt den Dateiinhalt abhängig vom Format (JSON, XML oder CSV) */\nfunction buildFileContents(bufferToSave, format, existingContent = \"\") {\n    // node.log(\"Erstelle Dateiinhalt im Format \" + format + \" für \" + bufferToSave.length + \" Einträge.\");\n    switch (format) {\n        case \"xml\":\n            return buildXML(bufferToSave, existingContent);\n        case \"csv\":\n            return buildCSV(bufferToSave, existingContent);\n        case \"json\":\n        default:\n            return buildJSON(bufferToSave, existingContent);\n    }\n}\n\n/** Ermittelt die passende Dateiendung aus dem Format */\nfunction getFileExtension(format) {\n    switch (format) {\n        case \"xml\": return \"xml\";\n        case \"csv\": return \"csv\";\n        default: return \"json\";\n    }\n}\n\n/** JSON-Stringify mit optionaler Anfüge-Logik */\nfunction buildJSON(bufferToSave, existingContent) {\n    if (config.fileMode === \"append\" && existingContent) {\n        try {\n            let existingData = JSON.parse(existingContent);\n            if (Array.isArray(existingData)) {\n                existingData.push(...bufferToSave);\n            } else {\n                existingData = [...bufferToSave];\n            }\n            return JSON.stringify(existingData, null, 2);\n        } catch (err) {\n            node.error(\"JSON Parsing Error: \" + err.message);\n        }\n    }\n    return JSON.stringify(bufferToSave, null, 2);\n}\n\n/** CSV-Datei mit Header und Anfüge-Option */\nfunction buildCSV(bufferToSave, existingContent) {\n    const lines = existingContent ? existingContent.split(\"\\n\") : [\"DatapointId,Value,Timestamp\"];\n    bufferToSave.forEach(dp => {\n        // Ggf. weitere Escapes notwendig, wenn Kommas im Value\n        lines.push(`${dp.DatapointId},${dp.Value},${dp.Timestamp}`);\n    });\n    return lines.join(\"\\n\");\n}\n\n/** XML-Datei mit optionaler Anfüge-Logik */\nfunction buildXML(bufferToSave, existingContent) {\n    let xmlData = existingContent ? existingContent.replace(\"</data>\", \"\") : \"<data>\\n\";\n    bufferToSave.forEach(dp => {\n        xmlData += `  <datapoint>\\n`;\n        xmlData += `    <DatapointId>${dp.DatapointId}</DatapointId>\\n`;\n        xmlData += `    <Value>${dp.Value}</Value>\\n`;\n        xmlData += `    <Timestamp>${dp.Timestamp}</Timestamp>\\n`;\n        xmlData += `  </datapoint>\\n`;\n    });\n    xmlData += \"</data>\";\n    return xmlData;\n}\n\n// -----------------------------------------------\n// 3) Hauptlogik: Datensammlung und Timer\n// -----------------------------------------------\n\n// a) Bestehenden Buffer aus dem Context holen\nvar buffer = context.get('buffer') || [];\n// node.log(\"Buffer initialisiert. Aktueller Buffer-Inhalt: \" + JSON.stringify(buffer));\n\n// b) Datenpunkt erzeugen\nvar topicParts = msg.topic.split(config.topicSeparator).filter(part => part !== '');\nvar datapointId = topicParts[topicParts.length - 1] || \"unknown\";\n\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()\n};\n// node.log(\"Neuer Datenpunkt erzeugt: \" + JSON.stringify(datapoint));\n\n// c) In den Buffer einfügen\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n// node.log(\"Datenpunkt dem Buffer hinzugefügt. Buffer-Länge: \" + buffer.length);\n\n// d) Status aktualisieren\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// e) Timer-Logik: Daten nach config.intervalMs in Datei schreiben\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    // node.log(\"Timer gestartet für Intervall: \" + config.intervalMs + \" ms\");\n\n    setTimeout(function () {\n        // 1) Status: Speichern\n        updateStatus(\"Saving data ...\", \"yellow\", \"ring\");\n        // node.log(\"Timer ausgelöst. Starte Speicherung der Daten.\");\n\n        // 2) Buffer holen\n        var bufferToSave = context.get('buffer') || [];\n        // node.log(\"Anzahl der zu speichernden Einträge: \" + bufferToSave.length);\n\n        // 3) Dateiname & Pfad ermitteln\n        var ext = getFileExtension(config.fileFormat);\n        var fileName;\n\n        if (config.fileMode === \"append\") {\n            fileName = `${config.fileName}.${ext}`; // Feste Datei\n        } else {\n            var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            fileName = `${config.fileName}_${timestamp}.${ext}`; // Basisname + Zeitstempel\n        }\n        var fullPath = path.join(config.filePath, fileName);\n        // node.log(\"Ermittelter Dateiname: \" + fileName + \" im Verzeichnis: \" + config.filePath);\n\n        // 4) Verzeichnis erstellen, falls nicht vorhanden\n        try {\n            fs.mkdirSync(config.filePath, { recursive: true });\n            // node.log(\"Verzeichnis vorhanden oder erfolgreich erstellt: \" + config.filePath);\n        } catch (e) {\n            node.error(\"Verzeichnis konnte nicht erstellt werden: \" + e.message);\n            updateStatus(\"Dir error\", \"red\", \"ring\");\n            context.set('timerSet', false);\n            return;\n        }\n\n        // 5) Falls append-Modus, existierenden Inhalt lesen\n        let existingContent = \"\";\n        if (config.fileMode === \"append\" && fs.existsSync(fullPath)) {\n            try {\n                existingContent = fs.readFileSync(fullPath, 'utf8');\n                // node.log(\"Bestehenden Dateiinhalt erfolgreich gelesen.\");\n            } catch (err) {\n                node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n            }\n        }\n\n        // 6) Dateiinhalt erstellen\n        var fileContents = buildFileContents(bufferToSave, config.fileFormat, existingContent);\n        // node.log(\"Dateiinhalt erstellt.\");\n\n        // 7) Datei schreiben\n        fs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n            if (err) {\n                node.error(\"File write error: \" + err.message);\n                updateStatus(\"Saving error\", \"red\", \"ring\");\n            } else {\n                // node.log(\"Datei erfolgreich gespeichert: \" + fullPath);\n                updateStatus(\"Data saved (\" + bufferToSave.length + \" items)\", \"green\", \"dot\");\n            }\n        });\n\n        // 8) Buffer & Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n        // node.log(\"Buffer und Timer-Flag zurückgesetzt.\");\n\n    }, config.intervalMs);\n}\n\n// Keine reguläre Ausgabe\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 450,
        "y": 80,
        "wires": []
    },
    {
        "id": "e78f387d4ba01882",
        "type": "mqtt in",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 80,
        "wires": [
            [
                "424f5da4789c7d8e"
            ]
        ]
    },
    {
        "id": "a101bcd063f6e0e4",
        "type": "status",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "scope": null,
        "x": 360,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "a348ffb0a5633da2",
        "type": "function",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = msg.endpoint       || env.get(\"OPCUA_ENDPOINT\")       || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = msg.objectId       || env.get(\"METHOD_OBJECTID\")      || \"ns=3;s=Demo.Method\";\nconst methodId    = msg.methodId       || env.get(\"METHOD_ID\")            || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs = msg.methodArgs      || env.get(\"METHOD_ARGS\")          || \"\"\nconst checkNodeId = msg.checkNodeId    || env.get(\"CHECK_NODEID\")         || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = msg.imageNodeId    || env.get(\"IMAGE_NODEID\")         || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = msg.ackNodeId      || env.get(\"ACK_NODEID\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = msg.basePath       || env.get(\"BASE_PATH\")            || \"./data/images\";\nconst device      = msg.device         || env.get(\"DEVICE\")               || \"local-1\";\nconst enableUpload= (msg.enableUpload  || env.get(\"ENABLE_UPLOAD\")        || \"true\").toLowerCase();\nconst uploadUrl   = msg.uploadUrl      || env.get(\"UPLOAD_URL\")           || \"http://localhost:7777/opc-upload\";\nconst additionalHeaders = msg.headers  || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(msg.securityModeVar || env.get(\"OPCUA_SECURITY_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(msg.securityPolicyVar || env.get(\"OPCUA_SECURITY_POLICY\") || \"NONE\").toUpperCase();\nconst username          = msg.username || env.get(\"OPCUA_USER\") || \"\";\nconst password          = msg.password || env.get(\"OPCUA_PASSWORD\") || \"\";\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        savedFilePath = await saveImage(base64String, basePath, device);\n        node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        await writeBoolean(session, ackNodeId, true);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(savedFilePath, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            savedFilePath,\n            uploaded: (enableUpload === \"true\"),\n            image: base64String\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const inputArguments = methodArgs ? JSON.parse(methodArgs).map(arg => ({\n        dataType: opcua.DataType[arg.dataType] || opcua.DataType.String, // Standard: String\n        value: arg.value\n    })) : [];\n\n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments: []\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(filePath, url, headers = {}) {\n    const fileData = await fs.readFile(filePath);\n    const defaultHeaders = {\n        // \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...headers };\n\n    // Konfiguration für Axios anpassen, wenn HTTPS genutzt wird\n    let axiosConfig = {\n        headers: mergedHeaders,\n    };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({\n            rejectUnauthorized: false  // Deaktiviert die Prüfung selbstsignierter Zertifikate\n        });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "20",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 470,
        "y": 280,
        "wires": [
            [
                "b96815da0497ae16"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "f8828b8e3af04a58",
        "type": "http in",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "HTTP -IN- POST",
        "url": "${IN_ENDPOINT}",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 420,
        "y": 160,
        "wires": [
            [
                "842b6ef57c490524"
            ]
        ]
    },
    {
        "id": "b96815da0497ae16",
        "type": "http response",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "HTTP Response",
        "statusCode": "200",
        "headers": {},
        "x": 500,
        "y": 360,
        "wires": []
    },
    {
        "id": "842b6ef57c490524",
        "type": "function",
        "z": "dac356dc77e3d814",
        "g": "0e108f67fce9da41",
        "name": "Get HTTP-Daten",
        "func": "// Hole die Daten aus dem Request Body (JSON)\n// und übertrage sie in msg.* Variablen\nlet reqBody = msg.req.body || {};\n\n// Helper-Funktion zur Übermittlung von Statusmeldungen\nfunction updateStatus(statusObj) {\n    node.send([null, { _subflowStatus: statusObj }]);\n}\n\n// Beispielhafter Status zu Beginn der Verarbeitung:\nupdateStatus({ fill: \"grey\", shape: \"dot\", text: \"Mapping HTTP-Daten...\" });\n\n// Übertrage Felder aus dem Request in msg\nmsg.endpoint = reqBody.endpoint;\nmsg.objectId = reqBody.objectId;\nmsg.methodId = reqBody.methodId;\nmsg.methodArgs = reqBody.methodArguments;\nmsg.checkNodeId = reqBody.checkNodeId;\nmsg.imageNodeId = reqBody.imageNodeId;\nmsg.ackNodeId = reqBody.ackNodeId;\nmsg.basePath = reqBody.basePath;\nmsg.device = reqBody.device;\nmsg.enableUpload = reqBody.enableUpload; // \"true\"/\"false\"\nmsg.uploadUrl = reqBody.uploadUrl;\nmsg.headers = reqBody.headers;\n\n// Optional: Security / Login\nmsg.securityModeVar = reqBody.securityModeVar;\nmsg.securityPolicyVar = reqBody.securityPolicyVar;\nmsg.username = reqBody.username.String;\nmsg.password = reqBody.password.String;\n\n// Konvertiere die Security-Variablen in Strings und setze Standardwerte falls nötig\nmsg.securityModeVar = (msg.securityModeVar || \"None\").toString();\nmsg.securityPolicyVar = (msg.securityPolicyVar || \"None\").toString();\n\n// Setze Standardwerte, falls der String \"none\" (unabhängig von der Groß-/Kleinschreibung) übergeben wurde\nif (msg.securityModeVar.toLowerCase() === \"none\") {\n    msg.securityModeVar = \"None\";\n}\nif (msg.securityPolicyVar.toLowerCase() === \"none\") {\n    msg.securityPolicyVar = \"None\";\n}\n\n// Mapping der Security Modes und Policies auf OPC-UA Konstanten\nconst securityModes = {\n    \"None\": opcua.MessageSecurityMode.None,\n    \"Sign\": opcua.MessageSecurityMode.Sign,\n    \"SignAndEncrypt\": opcua.MessageSecurityMode.SignAndEncrypt\n};\n\nconst securityPolicies = {\n    \"None\": opcua.SecurityPolicy.None,\n    \"Basic128Rsa15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"Basic256\": opcua.SecurityPolicy.Basic256,\n    \"Basic256Sha256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Setze die korrekten Werte basierend auf der Eingabe\nmsg.securityModeVar = securityModes[msg.securityModeVar] || opcua.MessageSecurityMode.None;\nmsg.securityPolicyVar = securityPolicies[msg.securityPolicyVar] || opcua.SecurityPolicy.None;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            }
        ],
        "x": 470,
        "y": 220,
        "wires": [
            [
                "a348ffb0a5633da2"
            ]
        ]
    },
    {
        "id": "7305073267fb70ed",
        "type": "status",
        "z": "dac356dc77e3d814",
        "name": "",
        "scope": null,
        "x": 420,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "bcee19f0a4e24893",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = env.get(\"OPC_ENDPOINT\")         || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = env.get(\"M_NODE_PARENT\")        || \"ns=3;s=Demo.Method\";\nconst methodId    = env.get(\"M_NODE_IMAGE\")         || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs  = env.get(\"M_ARGS\")               || \"\"\nconst checkNodeId = env.get(\"NODE_CHECK\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\")           || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = env.get(\"NODE_ACK_READ\")        || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = env.get(\"BASEPATH\")             || \"./data/images\";\nconst device      = env.get(\"DEVICE_ID\")            || \"local-1\";\nconst enableUpload= env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl   = env.get(\"UPLOAD_URL\");\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        // node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        // node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        // node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        // savedFilePath = await saveImage(base64String, basePath, device);\n        // node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        // node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        // node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            // node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            // uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n    \n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // node.log(\"Using Headers: \" + JSON.stringify(mergedHeaders, null, 2));\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 470,
        "y": 440,
        "wires": [
            [
                "c7d47dd6e033c7ef"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "c7d47dd6e033c7ef",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n// const fileName = filePath.split(\"/\").pop(); // Letzter Abschnitt nach dem \"/\"\n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 520,
        "wires": [
            [
                "f64651dd0ef28470"
            ]
        ]
    },
    {
        "id": "f64651dd0ef28470",
        "type": "http request",
        "z": "dac356dc77e3d814",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 610,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "da0584c47df5ed3d",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = env.get(\"OPC_ENDPOINT\")         || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = env.get(\"M_NODE_PARENT\")        || \"ns=3;s=Demo.Method\";\nconst methodId    = env.get(\"M_NODE_IMAGE\")         || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs  = env.get(\"M_ARGS\")               || \"\"\nconst checkNodeId = env.get(\"NODE_CHECK\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\")           || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = env.get(\"NODE_ACK_READ\")        || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = env.get(\"BASEPATH\")             || \"./data/images\";\nconst device      = env.get(\"DEVICE_ID\")            || \"local-1\";\nconst enableUpload= env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl   = env.get(\"UPLOAD_URL\");\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        // node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        // node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        // node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        // savedFilePath = await saveImage(base64String, basePath, device);\n        // node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        // node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        // node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            // node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            // uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n    \n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // node.log(\"Using Headers: \" + JSON.stringify(mergedHeaders, null, 2));\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 530,
        "y": 20,
        "wires": [
            [
                "7a91daf2877a46a5"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "0b0d19296544b9f8",
        "type": "status",
        "z": "a83312e9e2e175ac",
        "name": "",
        "scope": null,
        "x": 80,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "18c462c840ed1a77",
        "type": "http request",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1130,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "7a91daf2877a46a5",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n// const fileName = filePath.split(\"/\").pop(); // Letzter Abschnitt nach dem \"/\"\n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 20,
        "wires": [
            [
                "18c462c840ed1a77"
            ]
        ]
    },
    {
        "id": "92f6fd0436ca3513",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "name": "OPC-Image-Capture-Process via GO Backend",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process via Go Backend\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen aus der Umgebung\nconst endpoint = env.get(\"OPC_ENDPOINT\") || \"opc.tcp://192.168.0.84:48010\";\nconst objectId = env.get(\"M_NODE_PARENT\") || \"ns=3;s=Demo.Method\";\nconst methodId = env.get(\"M_NODE_IMAGE\") || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs = env.get(\"M_ARGS\") || \"\";\nconst checkNodeId = env.get(\"NODE_CHECK\") || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\") || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId = env.get(\"NODE_ACK_READ\") || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath = env.get(\"BASEPATH\") || \"./data/images\";\nconst device = env.get(\"DEVICE_ID\");\nconst enableUpload = env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl = env.get(\"UPLOAD_URL\");\n\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/json\" };\n\n// 2) Lese Security-Parameter aus der Umgebung\nconst securityModeVar = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username = env.get(\"OPC_USER\") || \"\";\nconst password = env.get(\"OPC_PW\") || \"\";\n\n// 3) Backend-URL für die Verarbeitung\nconst backendUrl = env.get(\"BACKEND_URL\") || \"http://iot-gateway:8088/api/img-process\";\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    try {\n        // 4) Payload für das Go-Backend vorbereiten\n        const payload = {\n            endpoint,\n            objectId,\n            methodId,\n            methodArgs,\n            checkNodeId,\n            imageNodeId,\n            ackNodeId,\n            basePath,\n            deviceId: device,\n            enableUpload,\n            uploadUrl,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"\",\n            password: password || \"\",\n            headers: additionalHeaders\n        };\n\n        // 5) Anfrage an das Go-Backend senden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sending request...\" });\n        const response = await axios.post(backendUrl, payload, { headers: additionalHeaders });\n\n        // 6) Überprüfe die Antwort des Go-Backends\n        if (response.status !== 200 || !response.data.success) {\n            throw new Error(`Backend error: ${response.data.error || \"Unknown error\"}`);\n        }\n\n        // 7) Erfolgreiche Verarbeitung\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n\n        msg.payload = {\n            success: true,\n            endpoint: response.data.endpoint,\n            securityMode: response.data.securityMode,\n            securityPolicy: response.data.securityPolicy,\n            username: response.data.username,\n            image: response.data.image,\n            device_id: response.data.device_id,\n            uploaded: response.data.uploaded || false\n        };\n\n        return msg;\n    } catch (err) {\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n        node.error(err.message, msg);\n        throw err;\n    }\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);\n",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 540,
        "y": 100,
        "wires": [
            []
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "8b0261fb901db5f1",
        "type": "influxdb in",
        "z": "ef4290a715908540",
        "influxdb": "${INFLUXDB}",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 380,
        "y": 80,
        "wires": [
            [
                "92542095e6a14c91"
            ]
        ]
    },
    {
        "id": "498350a0e7d7fa21",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER (sec)\"); // Erwartet einen numerischen Wert in Sekunden\n\nmsg.startTime = process.hrtime();\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 3600; // Standard: 1 Stunde (3600 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 210,
        "y": 80,
        "wires": [
            [
                "8b0261fb901db5f1"
            ]
        ]
    },
    {
        "id": "92542095e6a14c91",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "http send",
        "func": "/**\n * Node-RED Function: Datenversand (Send) - für InfluxDB-Daten\n *\n * - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n * - Versendet diese per HTTP POST an den konfigurierten Endpoint.\n * - HTTP-Header und Endpoint können über Umgebungsvariablen (env) oder msg überschrieben werden.\n * - Aktualisiert ausschließlich den Status (node.status).\n */\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers  = env.get(\"HEADER\") || msg.headers;\n\n// Prüfe, ob die Startzeit vorhanden ist\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    return null;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    return null;\n}\n\n// Status: Sende Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Send Data ...\" });\n\n// Erstelle den POST-Datenstring (JSON) aus msg.payload\nvar postData = JSON.stringify(msg.payload);\n\n// Zerlege den Endpoint in seine Bestandteile\nvar endpointUrl = url.parse(endpoint);\nvar options = {\n    hostname: endpointUrl.hostname,\n    port: endpointUrl.port,\n    path: endpointUrl.path,\n    method: 'POST',\n    headers: Object.assign({}, headers, {\n        'Content-Length': Buffer.byteLength(postData),\n        'Content-Type': 'application/json'\n    })\n};\n\n// Initialisiere den HTTP POST Request\nvar req = http.request(options, function (res) {\n    var responseBody = \"\";\n    res.setEncoding('utf8');\n    res.on('data', function (chunk) {\n        responseBody += chunk;\n    });\n    res.on('end', function () {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: `Daten versendet (${entryCount} Einträge), Dauer: ${durationMs.toFixed(2)} ms`\n        });\n        // node.status({ fill: \"green\", shape: \"dot\", text: \"Daten versendet (\" + entryCount + \" Einträge), Dauer: ${durationMs.toFixed(2)} ms\" });\n    });\n});\n\nreq.on('error', function (e) {\n    node.error(\"HTTP POST request error: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Versand fehlgeschlagen\" });\n});\n\n// Sende den POST-Datenstring\nreq.write(postData);\nreq.end();\n\n// Es wird keine Nachricht weitergereicht.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 540,
        "y": 80,
        "wires": []
    },
    {
        "id": "16c9290388d72e82",
        "type": "status",
        "z": "ef4290a715908540",
        "name": "",
        "scope": null,
        "x": 260,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "fa7abbee5d7c7eb7",
        "type": "influxdb in",
        "z": "f5c5556a9e4eb0ae",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 380,
        "y": 80,
        "wires": [
            [
                "a2fa737c0195922b"
            ]
        ]
    },
    {
        "id": "4a16a8db342b7323",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER (sec)\"); // Erwartet einen numerischen Wert in Sekunden\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 3600; // Standard: 1 Stunde (3600 Sekunden)\n}\n\n// Erfassen des Startzeitpunktes\nmsg.startTime = process.hrtime();\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 210,
        "y": 80,
        "wires": [
            [
                "fa7abbee5d7c7eb7"
            ]
        ]
    },
    {
        "id": "a2fa737c0195922b",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "influx-to-file",
        "func": "/**\n * Node-RED Function: Speichert die empfangenen Daten in eine Datei.\n *\n * - Unterstützt verschiedene Formate (JSON, CSV, XML).\n * - Kann entweder an eine Datei anhängen oder eine neue Datei mit Timestamp erstellen.\n * - Erstellt automatisch das Verzeichnis, falls es nicht existiert.\n * - Aktualisiert den Node-Status entsprechend.\n */\n\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    return null;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n// Konfiguration aus Umgebungsvariablen oder msg übernehmen\nvar filePath = env.get(\"FILE_PATH\") || msg.filePath || \"/data\";  // Standardverzeichnis\nvar fileName = env.get(\"FILENAME\") || msg.fileName || \"influx_data\"; // Basis-Dateiname\nvar fileMode = env.get(\"FILE_MODE\") || msg.fileMode || \"append\"; // \"append\" oder \"new\"\nvar fileFormat = (env.get(\"FILE_FORMAT\") || msg.fileFormat || \"json\").toLowerCase(); // \"json\", \"csv\", \"xml\"\n\n// Überprüfen, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu speichern\" });\n    return null;\n}\n\n// Status: Speichern der Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Speichere Daten...\" });\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Funktion zur Umwandlung der Daten in das gewünschte Format\nfunction convertData(data, format, existingContent = \"\") {\n    // Umwandlung der Datenstruktur\n    let transformedData = data.map(item => ({\n        DatapointId: item.datapointId,\n        Value: item._value,\n        Timestamp: formatTimestamp(item._time)\n    }));\n\n    if (format === \"json\") {\n        if (fileMode === \"append\" && existingContent) {\n            try {\n                let existingData = JSON.parse(existingContent);\n                if (Array.isArray(existingData)) {\n                    existingData.push(...transformedData);\n                } else {\n                    existingData = [...transformedData];\n                }\n                return JSON.stringify(existingData, null, 2);\n            } catch (err) {\n                node.error(\"JSON Parsing Error: \" + err.message);\n            }\n        }\n        return JSON.stringify(transformedData, null, 2);\n    }\n    if (format === \"csv\") {\n        let keys = [\"DatapointId\", \"Value\", \"Timestamp\"];\n        let csvRows = transformedData.map(row => keys.map(k => row[k]).join(\",\"));\n        if (fileMode === \"append\" && existingContent) {\n            return existingContent + \"\\n\" + csvRows.join(\"\\n\");\n        }\n        return keys.join(\",\") + \"\\n\" + csvRows.join(\"\\n\");\n    }\n    if (format === \"xml\") {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<data>\\n';\n        transformedData.forEach(item => {\n            xml += \"  <entry>\\n\";\n            xml += `    <DatapointId>${item.DatapointId}</DatapointId>\\n`;\n            xml += `    <Value>${item.Value}</Value>\\n`;\n            xml += `    <Timestamp>${item.Timestamp}</Timestamp>\\n`;\n            xml += \"  </entry>\\n\";\n        });\n        xml += \"</data>\";\n        return xml;\n    }\n    return JSON.stringify(transformedData, null, 2); // Fallback: JSON\n}\n\n\n// Dateiname & Pfad ermitteln\nvar fileExtension = fileFormat === \"xml\" ? \"xml\" : fileFormat === \"csv\" ? \"csv\" : \"json\";\nvar finalFileName = fileMode === \"new\"\n    ? `${fileName}_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExtension}`\n    : `${fileName}.${fileExtension}`;\nvar fullPath = path.join(filePath, finalFileName);\n\n// Falls nötig, Verzeichnis erstellen\ntry {\n    fs.mkdirSync(filePath, { recursive: true });\n} catch (e) {\n    node.error(\"Fehler beim Erstellen des Verzeichnisses: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Verzeichnisfehler\" });\n    return null;\n}\n\n// Falls append-Modus, existierenden Inhalt lesen\nlet existingContent = \"\";\nif (fileMode === \"append\" && fs.existsSync(fullPath)) {\n    try {\n        existingContent = fs.readFileSync(fullPath, 'utf8');\n    } catch (err) {\n        node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n    }\n}\n\n// Dateiinhalt generieren\nvar fileContents = convertData(msg.payload, fileFormat, existingContent);\n\n// Datei schreiben\nfs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n    if (err) {\n        node.error(\"Fehler beim Speichern der Datei: \" + err.message);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Speichern fehlgeschlagen\" });\n    } else {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: `Gespeichert (${entryCount} Einträge), Dauer: ${durationMs.toFixed(2)} ms`\n        });\n\n        // Ausgabe der Zeitmessung für Debugging\n        node.log(`Datei gespeichert in ${durationMs.toFixed(2)} ms: ${fullPath}`);\n    }\n});\n\n// Keine Weitergabe der Nachricht\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 550,
        "y": 80,
        "wires": []
    },
    {
        "id": "71c0dcf56b57e3e9",
        "type": "status",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "scope": null,
        "x": 60,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "ec3b319d5e4816bb",
        "type": "subflow:b784f457619f1095",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "REST | Device 1",
        "env": [
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "30",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "INTERVAL (ms)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "MQTT_BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "str"
            },
            {
                "name": "MQTT_TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 60,
        "wires": []
    },
    {
        "id": "a9ed63b5bb3b5849",
        "type": "subflow:b784f457619f1095",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "REST | Device 2",
        "env": [
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/2/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "INTERVAL (ms)",
                "value": "5000",
                "type": "num"
            },
            {
                "name": "MQTT_BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "str"
            },
            {
                "name": "MQTT_TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 120,
        "wires": []
    },
    {
        "id": "5c74eeaf79810b94",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "Save in File CSV || Device 10",
        "env": [
            {
                "name": "PATH",
                "value": "/data/shared/files",
                "type": "str"
            },
            {
                "name": "FORMAT",
                "value": "csv",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-10",
                "type": "str"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/10/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 420,
        "y": 120,
        "wires": []
    },
    {
        "id": "fdf5d55aa5e0946d",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "Save in File JSON || Device 10",
        "env": [
            {
                "name": "PATH",
                "value": "/data/shared/files",
                "type": "str"
            },
            {
                "name": "MODE",
                "value": "append",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-10",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "10",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/10/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 430,
        "y": 60,
        "wires": []
    },
    {
        "id": "6803fac32782bc06",
        "type": "subflow:2a3d9e44553dfac0",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "Save in File XML || Device 21",
        "env": [
            {
                "name": "PATH",
                "value": "/tmp/",
                "type": "str"
            },
            {
                "name": "FORMAT",
                "value": "xml",
                "type": "str"
            },
            {
                "name": "FILENAME",
                "value": "data-device-21",
                "type": "str"
            },
            {
                "name": "INTERVAL (sec)",
                "value": "5",
                "type": "num"
            },
            {
                "name": "BROKER",
                "value": "0b7c7515b1c6aa53",
                "type": "conf-type"
            },
            {
                "name": "TOPIC",
                "value": "data/opc-ua/21/#",
                "type": "str"
            },
            {
                "name": "INTERVAL (MS)",
                "value": "6000",
                "type": "num"
            }
        ],
        "x": 420,
        "y": 180,
        "wires": []
    },
    {
        "id": "940b2b5baea63939",
        "type": "inject",
        "z": "4071c101bbc3e907",
        "name": "cyclic trigger",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 130,
        "y": 340,
        "wires": [
            [
                "1e58e260edbe452b",
                "8c3c74570e164ae4"
            ]
        ]
    },
    {
        "id": "1e58e260edbe452b",
        "type": "subflow:ef4290a715908540",
        "z": "4071c101bbc3e907",
        "name": "Influx-to-REST",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "HEADER",
                "value": "{\"Content-Type\":\"application/json\"}",
                "type": "json"
            },
            {
                "name": "TIMER (sec)",
                "value": "60",
                "type": "str"
            }
        ],
        "x": 380,
        "y": 280,
        "wires": [],
        "info": "#### InfluxDB-to-REST Node\r\n#### Kategorie: IDPM-Data Forwarding\r\n#### Beschreibung:\r\nDer InfluxDB-to-REST-Subflow ermöglicht das periodische Abrufen von Daten aus einer InfluxDB-Datenbank und sendet diese per HTTP-POST an eine definierte REST-API.\r\nDie Node erlaubt eine flexible Konfiguration der Ziel-URL, HTTP-Header und Abfrageintervalle.\r\n\r\n#### Funktionsweise:\r\n 1. Abfrageerstellung:\r\n\r\nDie Node generiert eine Flux-Query, um die letzten n Sekunden aus der InfluxDB abzufragen.\r\nDer Zeitbereich kann über die Umgebungsvariable TIMER (sec) konfiguriert werden.\r\nDer Filter basiert auf der DEVICE_ID, um gerätespezifische Daten zu extrahieren.\r\n 2. Datenabruf:\r\n\r\nDie generierte Flux-Query wird an die InfluxDB gesendet.\r\nDie abgerufenen Daten werden als JSON-Objekt weitergeleitet.\r\nDatenversand:\r\n\r\nDie abgerufenen Daten werden per HTTP-POST an den konfigurierten REST-API-Endpoint gesendet.\r\nDie Ziel-URL und HTTP-Header können über die Umgebungsvariablen URL und HEADER definiert werden.\r\nStatusanzeige:\r\n\r\nWährend des Prozesses werden Statusmeldungen zur Laufzeitdauer und Anzahl der gesendeten Datensätze ausgegeben.\r\nKonfigurierbare Umgebungsvariablen:\r\nVariable\tTyp\tStandardwert\tBeschreibung\r\nINFLUXDB\tInfluxDB\t-\tVerknüpfung zur InfluxDB-Instanz\r\nURL\tString\t\"http://192.168.0.84:4999\"\tZiel-URL für den REST-Request\r\nHEADER\tJSON\t{}\tZusätzliche HTTP-Header im JSON-Format\r\nDEVICE_ID\tString\t1\tID des Geräts, dessen Daten abgefragt werden\r\nTIMER (sec)\tString\t10\tZeitintervall für die Datenabfrage (in Sekunden)\r\nEinsatzmöglichkeiten:\r\n✔ Automatische Übertragung von Sensordaten aus InfluxDB an REST-APIs\r\n✔ Integration in IoT-Datenpipelines für Cloud- und Edge-Anwendungen\r\n✔ Datensynchronisation mit externen Datenplattformen"
    },
    {
        "id": "8c3c74570e164ae4",
        "type": "subflow:f5c5556a9e4eb0ae",
        "z": "4071c101bbc3e907",
        "name": "",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "FILE_PATH",
                "value": "/data/shared/",
                "type": "str"
            },
            {
                "name": "TIMER (sec)",
                "value": "600",
                "type": "str"
            }
        ],
        "x": 370,
        "y": 340,
        "wires": [],
        "info": "Hier ist eine geeignete Node-RED-Beschreibung für den **\"Influx-to-File\"** Subflow:\r\n\r\n---\r\n\r\n### **Influx-to-File Node**\r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **Influx-to-File**-Subflow ermöglicht das periodische Abrufen von Daten aus einer **InfluxDB**-Datenbank und speichert diese in einer Datei. Die Daten können in den Formaten **JSON, CSV oder XML** gespeichert werden.  \r\nDie Node unterstützt sowohl das **Anhängen** an bestehende Dateien als auch das **Erstellen** neuer Dateien mit einem Zeitstempel.  \r\n\r\n#### **Funktionsweise:**\r\n1. **Abfrageerstellung:**  \r\n   - Die Node generiert eine **Flux-Query**, um die letzten *n* Sekunden aus der InfluxDB abzufragen.  \r\n   - Der Zeitbereich kann über die Umgebungsvariable `TIMER (sec)` konfiguriert werden.  \r\n   - Der Filter basiert auf der `DEVICE_ID`, um gerätespezifische Daten zu extrahieren.\r\n\r\n2. **Datenabruf:**  \r\n   - Die generierte Flux-Query wird an die InfluxDB gesendet.  \r\n   - Die abgerufenen Daten werden als JSON-Objekt weitergeleitet.  \r\n\r\n3. **Dateispeicherung:**  \r\n   - Die Daten werden im angegebenen `FILE_PATH` als JSON, CSV oder XML gespeichert.  \r\n   - Falls der Speicherpfad nicht existiert, wird er automatisch erstellt.  \r\n   - Bestehende Dateien können überschrieben (`new`) oder ergänzt (`append`) werden.  \r\n\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusmeldungen zur Laufzeitdauer und Anzahl der gespeicherten Datensätze ausgegeben.  \r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**\r\n| Variable       | Typ       | Standardwert | Beschreibung |\r\n|---------------|----------|-------------|-------------|\r\n| `INFLUXDB`    | InfluxDB | -           | Verknüpfung zur InfluxDB-Instanz |\r\n| `FILE_PATH`   | String   | `/data`     | Verzeichnis, in dem die Datei gespeichert wird |\r\n| `DEVICE_ID`   | String   | `1`         | ID des Geräts, dessen Daten abgefragt werden |\r\n| `TIMER (sec)` | String   | `1`         | Zeitintervall für die Datenabfrage (in Sekunden) |\r\n\r\n#### **Einsatzmöglichkeiten:**\r\n✔ Speicherung von Zeitreihenmesswerten aus einer InfluxDB  \r\n✔ Erstellung von Datenexporten für externe Systeme  \r\n✔ Regelmäßige Datensicherung oder Analysezwecke  "
    },
    {
        "id": "7c2c66976c1232ea",
        "type": "subflow:ef4290a715908540",
        "z": "4071c101bbc3e907",
        "name": "Influx-to-REST",
        "env": [
            {
                "name": "INFLUXDB",
                "value": "a1403f82a270e6f4",
                "type": "conf-type"
            },
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999/data/readingsarray",
                "type": "str"
            },
            {
                "name": "HEADER",
                "value": "{\"Content-Type\":\"application/json\"}",
                "type": "json"
            },
            {
                "name": "DEVICEID",
                "value": "14",
                "type": "str"
            },
            {
                "name": "TIMER (sec)",
                "value": "2",
                "type": "str"
            }
        ],
        "x": 380,
        "y": 400,
        "wires": []
    },
    {
        "id": "471967c8ff8469b0",
        "type": "subflow:a83312e9e2e175ac",
        "z": "e129ee69a298a464",
        "name": "Img-Cap-Process-1",
        "env": [
            {
                "name": "UPLOAD_URL",
                "value": "http://node-red:1880/opc-upload",
                "type": "str"
            }
        ],
        "x": 230,
        "y": 60,
        "wires": [
            [
                "9ec21dc807194186"
            ]
        ]
    },
    {
        "id": "f2a367057c5f98d6",
        "type": "subflow:a83312e9e2e175ac",
        "z": "e129ee69a298a464",
        "name": "Img-Cap-Process-2",
        "env": [
            {
                "name": "OPC_ENDPOINT",
                "value": "opc.tcp://192.168.0.84:48016",
                "type": "str"
            },
            {
                "name": "M_NODE_IMAGE",
                "value": "ns=3;s=Demo.Method.DoSomethingAfter10s",
                "type": "str"
            },
            {
                "name": "M_ARGS",
                "value": "{}",
                "type": "json"
            }
        ],
        "x": 230,
        "y": 280,
        "wires": [
            [
                "ef2d2c093d3c50ec"
            ]
        ]
    },
    {
        "id": "6f27e5ca18fd6d52",
        "type": "inject",
        "z": "e129ee69a298a464",
        "name": "Trigger",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 90,
        "y": 160,
        "wires": [
            [
                "471967c8ff8469b0",
                "f2a367057c5f98d6"
            ]
        ]
    },
    {
        "id": "9ec21dc807194186",
        "type": "image",
        "z": "e129ee69a298a464",
        "name": "",
        "width": 160,
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 460,
        "y": 60,
        "wires": []
    },
    {
        "id": "ef2d2c093d3c50ec",
        "type": "image",
        "z": "e129ee69a298a464",
        "name": "",
        "width": "200",
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 440,
        "y": 280,
        "wires": []
    },
    {
        "id": "cb83d0b9bbc23ce4",
        "type": "http in",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP POST /opc-upload",
        "url": "/opc-upload",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "b43ada02cf576d59"
            ]
        ]
    },
    {
        "id": "0dc25daa4866e6e4",
        "type": "http response",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP Response",
        "statusCode": "200",
        "headers": {},
        "x": 600,
        "y": 240,
        "wires": []
    },
    {
        "id": "b43ada02cf576d59",
        "type": "function",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "toBase64",
        "func": "msg.payload = msg.payload.toString(\"base64\")\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 180,
        "wires": [
            [
                "22f3e072ed258a2f"
            ]
        ]
    },
    {
        "id": "cf032448930f65c9",
        "type": "comment",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "Test Upload for debugging",
        "info": "",
        "x": 530,
        "y": 120,
        "wires": []
    },
    {
        "id": "22f3e072ed258a2f",
        "type": "image",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": true,
        "outputs": 1,
        "x": 400,
        "y": 240,
        "wires": [
            [
                "0dc25daa4866e6e4"
            ]
        ]
    },
    {
        "id": "981c7a177fa98054",
        "type": "s7 in",
        "z": "e7b0b0bc76ad7903",
        "d": true,
        "g": "4fa0c14be559bdb6",
        "endpoint": "5007a50a62dcb950",
        "mode": "single",
        "variable": "Output_Num_1",
        "diff": false,
        "name": "",
        "x": 260,
        "y": 520,
        "wires": [
            [
                "6d52b6f1c958ee82",
                "5bfc5c4ac52ffcec"
            ]
        ]
    },
    {
        "id": "6d52b6f1c958ee82",
        "type": "mqtt out",
        "z": "e7b0b0bc76ad7903",
        "g": "4fa0c14be559bdb6",
        "name": "",
        "topic": "data/s7/14/[223] Q20",
        "qos": "2",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0b7c7515b1c6aa53",
        "x": 540,
        "y": 520,
        "wires": []
    },
    {
        "id": "5bfc5c4ac52ffcec",
        "type": "debug",
        "z": "e7b0b0bc76ad7903",
        "g": "4fa0c14be559bdb6",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 470,
        "y": 420,
        "wires": []
    }
]