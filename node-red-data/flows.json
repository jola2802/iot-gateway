[
    {
        "id": "4071c101bbc3e907",
        "type": "tab",
        "label": "Data Forwarding",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "e129ee69a298a464",
        "type": "tab",
        "label": "Image-Capture",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e7b0b0bc76ad7903",
        "type": "tab",
        "label": "Image-Upload",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "10b23f05464fa924",
        "type": "tab",
        "label": "OLD",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "b784f457619f1095",
        "type": "subflow",
        "name": "OLD - MQTT to REST",
        "info": "### **MQTT to REST Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **MQTT to REST**-Subflow sammelt kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten als JSON per HTTP POST an einen definierten REST API Endpoint versendet. Dabei gibt die Node Statusmeldungen (z. B. Buffergröße, Versandstatus) über den zweiten Ausgang zur Prozessüberwachung aus.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand ihres Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, einen **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gespeichert.\r\n\r\n2. **Zeitbasierter Versand:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (sec)`, steuert den Zeitpunkt des Datenversands.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Buffer als JSON serialisiert und per HTTP POST an den konfigurierten REST API Endpoint gesendet.\r\n\r\n3. **HTTP-Versand:**  \r\n   - Die Node erstellt aus dem Buffer den POST-Datenstring und sendet diesen unter Verwendung der konfigurierten HTTP-Header.  \r\n   - Der REST API Endpoint wird in der Umgebungsvariablen `URL` definiert.\r\n\r\n4. **Statusüberwachung:**  \r\n   - Über den zweiten Ausgang werden Statusmeldungen zur aktuellen Buffergröße und zum Versandstatus ausgegeben.\r\n\r\n#### **Beispiel für den Datenversand:**  \r\nAngenommen, der Buffer enthält zwei Datenpunkte, könnte das an den REST API Endpoint gesendete JSON-Dokument wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 22.5,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 45,\r\n    \"Timestamp\": \"2023-03-01T10:00:00.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses JSON wird mittels HTTP POST an den in `URL` definierten Endpoint versendet. Die HTTP-Header, beispielsweise `{\"Content-Type\": \"application/json\"}`, werden ebenfalls mitgeschickt.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable             | Typ        | Standardwert                                              | Beschreibung |\r\n|----------------------|------------|-----------------------------------------------------------|--------------|\r\n| `URL`                | String     | `\"https://url.com\"`                                       | REST API Endpoint für den HTTP POST Versand |\r\n| `HEADER`             | JSON       | `{\"Content-Type\":\"application/json\"}`                     | HTTP-Header, die beim Versand genutzt werden |\r\n| `INTERVAL (sec)`     | Num        | `60`                                                      | Zeitintervall (in Sekunden) nach dem der Buffer versendet wird |\r\n| `BROKER`             | MQTT-Broker| -                                                         | Verknüpfung zum MQTT-Broker |\r\n| `TOPIC`              | String     | `\"data/opc-ua/1/#\"`                                        | MQTT-Topic, über das die Daten empfangen werden |\r\n| `DEVICEID`           | String     | `\"1\"`                                                     | Gerätebezeichnung, die bei der Datenaggregation berücksichtigt wird |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und Weiterleitung von MQTT-Daten an REST-basierte Anwendungen  \r\n✔ Integration in IoT-Datenpipelines zur zentralen Verarbeitung und Speicherung von Sensordaten  \r\n✔ Überwachung und Statusprotokollierung der Datenübertragung zur Fehlerdiagnose  \r\n",
        "category": "OLD",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "URL",
                "type": "str",
                "value": "https://url.com",
                "ui": {
                    "icon": "font-awesome/fa-plug",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{\"Content-Type\":\"application/json\"}",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/opc-ua/1/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "DEVICE_ID",
                "type": "str",
                "value": "1",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect Data & Send to REST"
        },
        "color": "#3FADB5",
        "icon": "font-awesome/fa-map-signs",
        "status": {
            "x": 460,
            "y": 20,
            "wires": [
                {
                    "id": "fb4b6772875e2106",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "2a3d9e44553dfac0",
        "type": "subflow",
        "name": "OLD - MQTT to FILE",
        "info": "### **Collect & Save in File Node**  \r\n#### **Kategorie:** IDPM-Data Forwarding  \r\n#### **Beschreibung:**  \r\nDer **Collect & Save in File**-Subflow aggregiert kontinuierlich eintreffende Datenpunkte aus einem MQTT-Stream in einem internen Buffer. Nach Ablauf eines konfigurierbaren Zeitintervalls werden die gesammelten Daten in einem definierten Verzeichnis abgelegt. Dabei unterstützt die Node verschiedene Dateiformate (**JSON**, **CSV** oder **XML**) sowie zwei Modi: Das **Anhängen** an eine bestehende Datei oder das **Erstellen** einer neuen Datei mit Zeitstempel. Statusmeldungen zur aktuellen Buffergröße und dem Speichervorgang werden über den zweiten Ausgang ausgegeben.\r\n\r\n#### **Funktionsweise:**  \r\n1. **Datenaggregation:**  \r\n   - Eingehende MQTT-Nachrichten werden anhand des Topics in Datenpunkte umgewandelt, die jeweils eine **DatapointId**, den **Value** und einen **Zeitstempel** enthalten.  \r\n   - Diese Datenpunkte werden in einem internen Buffer gesammelt.\r\n\r\n2. **Zeitbasierte Speicherung:**  \r\n   - Ein Timer, konfiguriert über die Umgebungsvariable `INTERVAL (MS)`, steuert den Zeitpunkt der Speicherung.  \r\n   - Nach Ablauf des definierten Intervalls wird der gesamte Bufferinhalt ausgelesen und in eine Datei geschrieben.\r\n\r\n3. **Dateiformat und Schreibmodus:**  \r\n   - Das Dateiformat (JSON, CSV oder XML) wird über die Umgebungsvariable `FORMAT` festgelegt.  \r\n   - Über den Modus (`MODE`) kann festgelegt werden, ob Daten an eine bestehende Datei angehängt („append“) oder in einer neuen Datei mit Zeitstempel abgelegt werden („new“).  \r\n   - Der Basis-Dateiname wird über die Umgebungsvariable `FILENAME` definiert.\r\n\r\n4. **Verzeichnisverwaltung und Status-Updates:**  \r\n   - Das Zielverzeichnis wird (falls notwendig) automatisch erstellt.  \r\n   - Während des gesamten Prozesses werden Statusmeldungen ausgegeben, die den aktuellen Bufferinhalt sowie den Erfolg des Schreibvorgangs dokumentieren.\r\n\r\n#### **Beispiel für einen gespeicherten Dateiinhalt (im JSON-Format):**  \r\nAngenommen, der Buffer enthält drei Datenpunkte, könnte der Inhalt der gespeicherten Datei wie folgt aussehen:\r\n\r\n```json\r\n[\r\n  {\r\n    \"DatapointId\": \"temperature\",\r\n    \"Value\": 21.7,\r\n    \"Timestamp\": \"2023-03-01T10:15:30.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"humidity\",\r\n    \"Value\": 48,\r\n    \"Timestamp\": \"2023-03-01T10:15:35.000Z\"\r\n  },\r\n  {\r\n    \"DatapointId\": \"pressure\",\r\n    \"Value\": 1013,\r\n    \"Timestamp\": \"2023-03-01T10:15:40.000Z\"\r\n  }\r\n]\r\n```\r\n\r\nDieses Beispiel zeigt, wie die Datenpunkte im JSON-Format strukturiert werden. Ähnliche Beispiele können für CSV oder XML erzeugt werden, wobei CSV z. B. wie folgt aussehen könnte:\r\n\r\n```\r\nDatapointId,Value,Timestamp\r\ntemperature,21.7,2023-03-01T10:15:30.000Z\r\nhumidity,48,2023-03-01T10:15:35.000Z\r\npressure,1013,2023-03-01T10:15:40.000Z\r\n```\r\n\r\n#### **Konfigurierbare Umgebungsvariablen:**  \r\n| Variable           | Typ            | Standardwert           | Beschreibung                                                   |\r\n|--------------------|----------------|------------------------|----------------------------------------------------------------|\r\n| `PATH`             | String         | `/data`                | Verzeichnis, in dem die Datei gespeichert wird                 |\r\n| `FORMAT`           | String         | `json`                 | Dateiformat: JSON, CSV oder XML                                |\r\n| `MODE`             | String         | `new`                  | Schreibmodus: „append“ oder „new“                              |\r\n| `FILENAME`         | String         | (leer)                 | Basis-Dateiname für die Speicherung                          |\r\n| `INTERVAL (sec)`   | Num            | `60`                   | Speichervorgang-Intervall in Sekunden (wird zur Anzeige genutzt)|\r\n| `INTERVAL (MS)`    | Num            | `60000`                | Speichervorgang-Intervall in Millisekunden                     |\r\n| `BROKER`           | MQTT-Broker    | -                      | Verknüpfung zum MQTT-Broker                                    |\r\n| `TOPIC`            | String         | `data/#`               | MQTT-Topic, über das Daten empfangen werden                    |\r\n\r\n#### **Einsatzmöglichkeiten:**  \r\n✔ Aggregation und persistente Speicherung von Zeitreihendaten aus MQTT-Streams  \r\n✔ Erstellung von Datenexporten für spätere Analysen oder externe Systeme  \r\n✔ Flexible Speicherung in verschiedenen Formaten und Modi (Anhängen oder neu erstellen)  \r\n",
        "category": "OLD",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "PATH",
                "type": "str",
                "value": "/data",
                "ui": {
                    "icon": "font-awesome/fa-file-text-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "json",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            },
            {
                "name": "MODE",
                "type": "str",
                "value": "new",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "INTERVAL (sec)",
                "type": "num",
                "value": "60",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "spinner",
                    "opts": {
                        "min": 1,
                        "max": 3600
                    }
                }
            },
            {
                "name": "BROKER",
                "type": "mqtt-broker",
                "value": "0b7c7515b1c6aa53",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "type": "conf-types"
                }
            },
            {
                "name": "TOPIC",
                "type": "str",
                "value": "data/#",
                "ui": {
                    "icon": "font-awesome/fa-external-link-square",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "Collect & Save in File"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 480,
            "y": 20,
            "wires": [
                {
                    "id": "a101bcd063f6e0e4",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "dac356dc77e3d814",
        "type": "subflow",
        "name": "Image-Capture-in-Node-RED",
        "info": "# Image Capture Process\r\n\r\nThis subflow implements a complete image capture process using OPC UA and is designed to perform all the steps required for the process in a single, consolidated flow. In detail, the subflow includes:\r\n\r\n## Connection setup and security configuration:\r\nAn OPC UA client is created that connects to an OPC UA server based on passed or environment variables (e.g. endpoint, security mode/policy, username and password).\r\n\r\n## Method call and process control:\r\nThe subflow calls a specified method on the server to initiate the image capture process. It then actively waits for a defined Boolean status (check node) to change in order to determine the right time for image processing.\r\n\r\n## Acknowledgement and optional upload:\r\nAfter successful saving, an acknowledge (Ack) is written back to the server. An HTTP POST upload of the saved file to a defined target endpoint is optional. Finally, the subflow returns a payload object with detailed information about the process, such as success message, security parameters used, storage path and the image string.\r\n\r\n## Important note:\r\nThis subflow is designed as a central component and **only needs to be implemented once in the entire Node-RED instance**. This ensures that all image acquisition processes are controlled consistently and centrally, resulting in optimized resource usage and a clear architecture.\r\n",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 220,
                "y": 200,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 700,
                "y": 200,
                "wires": [
                    {
                        "id": "bcee19f0a4e24893",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "IN_ENDPOINT",
                "type": "str",
                "value": "/opc-image",
                "ui": {
                    "icon": "font-awesome/fa-chain",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "OPC_ENDPOINT",
                "type": "str",
                "value": "opc.tcp://xx:48010"
            },
            {
                "name": "M_NODE_PARENT",
                "type": "str",
                "value": "ns=3;s=Demo.Methods"
            },
            {
                "name": "M_NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Methods.Multiply"
            },
            {
                "name": "M_ARGS",
                "type": "json",
                "value": "{\"a\":\"1\",\"b\":\"1\"}",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "NODE_CHECK",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean"
            },
            {
                "name": "NODE_IMAGE",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.ImageGIF"
            },
            {
                "name": "NODE_ACK_READ",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean"
            },
            {
                "name": "ENABLE_UPLOAD",
                "type": "str",
                "value": "false",
                "ui": {
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "true"
                                },
                                "v": "true"
                            },
                            {
                                "l": {
                                    "de": "false"
                                },
                                "v": "false"
                            }
                        ]
                    }
                }
            },
            {
                "name": "UPLOAD_URL",
                "type": "str",
                "value": ""
            },
            {
                "name": "HEADERS",
                "type": "json",
                "value": "{\"BLOB_TIME\":\"\"}"
            }
        ],
        "meta": {},
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "image-base64-string"
        ],
        "icon": "font-awesome/fa-exclamation",
        "status": {
            "x": 600,
            "y": 40,
            "wires": [
                {
                    "id": "7305073267fb70ed",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "a83312e9e2e175ac",
        "type": "subflow",
        "name": "Image-Capture",
        "info": "#### **Beschreibung**  \r\nDer **Img-Cap-Process-Backend**-Subflow sammelt alle für den Bildaufnahmeprozess relevanten Parameter – darunter OPC UA Verbindungsdaten, Methoden- und Node-IDs, Sicherheitskonfigurationen sowie Upload-Einstellungen – und überführt diese in ein strukturiertes JSON-Payload. Dieses Payload wird per HTTP POST an ein dediziertes Go-Backend übermittelt, das den kompletten Bildaufnahme- und Verarbeitungsprozess übernimmt. Das Ergebnis, beispielsweise in Form von Erfolgsmeldungen, Bilddaten und Metainformationen, wird anschließend an den weiteren Flow zurückgegeben.\r\n\r\n#### **Funktionsweise**  \r\n1. **Parameter-Sammlung:**  \r\n   - Der Subflow liest alle notwendigen Konfigurationsparameter entweder aus Umgebungsvariablen.  \r\n   - Hierzu zählen insbesondere der OPC UA Endpoint, die zu verwendenden Methoden- und Node-IDs.\r\n\r\n2. **Payload-Erstellung:**  \r\n   - Alle gesammelten Parameter werden in ein JSON-Objekt überführt, das sämtliche Informationen für den Bildaufnahmeprozess enthält.\r\n\r\n3. **Weiterleitung an das Go-Backend:**  \r\n   - Das JSON-Payload wird mittels HTTP POST an die konfigurierte Backend-URL gesendet.  \r\n   - Das Go-Backend führt den Bildaufnahmeprozess aus und liefert einen Verarbeitungsstatus als Antwort.\r\n\r\n4. **Ergebnisrückgabe:**  \r\n   - Das Resultat (z. B. Erfolgsmeldung, Bilddaten, Metainformationen) wird an den weiteren Flow zurückgereicht.\r\n\r\n#### **Konfigurierbare Umgebungsvariablen**\r\n\r\n| Variable           | Typ   | Standardwert                                    | Beschreibung                                                  |\r\n|--------------------|-------|-------------------------------------------------|---------------------------------------------------------------|\r\n| `OPC Endpoint`     | String| `\"opc.tcp://192.168.0.84:48010\"`                  | OPC UA Server Endpoint                                        |\r\n| `Device ID`        | String| `\"\"`                                            | Geräte-ID; wenn leer, wird diese automatisch aus bestehender Device-Tabelle gesucht oder Default-Wert vergeben (99999)|\r\n| `Object ID`    | String| `\"ns=3;s=Demo.Method\"`                           | Objekt-ID der OPC UA Methode                                  |\r\n| `Method ID`     | String| `\"ns=3;s=Demo.Method.Multiply\"`                  | Methoden-/Node-ID, die den Bildaufnahmeprozess triggert       |\r\n| `Method Args`           | JSON  | `{\"a\":\"5\",\"b\":\"11\"}`                             | Parameter für die Methode (im JSON-Format)                    |\r\n| `Check Node ID`       | String| `\"ns=3;s=Demo.Dynamic.Scalar.Boolean\"`           | Node-ID, die den Boolean-Status überwacht                     |\r\n| `Image Node ID`       | String| `\"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\"`          | Node-ID, von der der Bildstring ausgelesen wird               |\r\n| `Acknowledge Node ID`    | String| `\"ns=3;s=Demo.Dynamic.Scalar.Boolean\"`           | Node-ID, in die das ACK geschrieben wird                      |\r\n| `Upload URL`       | String| `\"https://192.168.0.84/nodered/opc-upload\"`       | URL für den optionalen Upload der Bilddaten, wenn leer dann kein Upload                   |\r\n| `Header`          | JSON  | `{\"Content-Type\":\"application/octet-stream\"}`   | Zusätzliche HTTP-Header für den Upload                        |\r\n\r\n#### **Einsatzmöglichkeiten**  \r\n- **Zentrale Steuerung der Bildaufnahme:**  \r\n  Vereinheitlicht die Steuerung des Bildaufnahmeprozesses durch zentrale Parameterübergabe an ein spezialisiertes Backend.\r\n\r\n- **Entlastung des Node-RED-Systems:**  \r\n  Lagert rechenintensive Bildverarbeitungsprozesse an ein dediziertes Go-Backend aus.\r\n\r\n- **Skalierbare Implementierung:**  \r\n  Ermöglicht eine einheitliche und skalierbare Realisierung von Bildaufnahmeprozessen innerhalb der gesamten Node-RED-Instanz.\r\n\r\n",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 240,
                "y": 100,
                "wires": [
                    {
                        "id": "92f6fd0436ca3513"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 910,
                "y": 100,
                "wires": [
                    {
                        "id": "92f6fd0436ca3513",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "OPC Endpoint",
                "type": "str",
                "value": "opc.tcp://192.168.0.84:48010",
                "ui": {
                    "icon": "font-awesome/fa-location-arrow",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Device ID",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-microchip",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Object ID",
                "type": "str",
                "value": "ns=3;s=Demo.Method",
                "ui": {
                    "icon": "font-awesome/fa-cube",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Method ID",
                "type": "str",
                "value": "ns=3;s=Demo.Method.Multiply",
                "ui": {
                    "icon": "font-awesome/fa-camera",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Method Args",
                "type": "json",
                "value": "{\"a\":\"5\",\"b\":\"11\"}",
                "ui": {
                    "icon": "font-awesome/fa-th-large",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "Check Node ID",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "icon": "font-awesome/fa-check-circle",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Image Node ID",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.ImageGIF",
                "ui": {
                    "icon": "font-awesome/fa-image",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Acknowledge Node ID",
                "type": "str",
                "value": "ns=3;s=Demo.Dynamic.Scalar.Boolean",
                "ui": {
                    "icon": "font-awesome/fa-check",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Upload URL",
                "type": "str",
                "value": "https://192.168.0.84/nodered/opc-upload",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Header",
                "type": "json",
                "value": "{\"Content-Type\":\"application/octet-stream\"}",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "opc-image-capture",
            "type": "opc-image-capture",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "A node to grab images from an opc-ua server.",
            "keywords": "opc-ua, gateway",
            "license": "Apache-2.0"
        },
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "image"
        ],
        "icon": "font-awesome/fa-camera-retro",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "0b0d19296544b9f8",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ef4290a715908540",
        "type": "subflow",
        "name": "InfluxDB to REST",
        "info": "### **Beschreibung**  \r\nDer **InfluxDB to REST** Subflow ermöglicht den periodischen Abruf von Sensordaten aus einer InfluxDB-Datenbank und deren anschließende Übertragung per HTTP POST an einen definierten REST-API-Endpunkt. Die Node ist speziell für IoT-Datenpipelines konzipiert und erlaubt eine flexible Konfiguration der Ziel-URL, HTTP-Header und Abfrageintervalle. Dadurch können Daten aus InfluxDB nahtlos in Cloud- oder Edge-Anwendungen integriert werden.\r\n\r\n### **Funktionsweise**  \r\n1. **Abfrageerstellung:**  \r\n   - Generierung einer Flux-Query, die Daten aus einem dynamisch konfigurierten Zeitintervall (`TIMER`) abfragt.  \r\n   - Filterung der Daten anhand der `DEVICE_ID`, um gerätespezifische Informationen zu extrahieren.\r\n2. **Datenabruf:**  \r\n   - Die erstellte Flux-Query wird an die InfluxDB gesendet und die ermittelten Daten werden als JSON-Objekt abgerufen.\r\n3. **Datenversand:**  \r\n   - Die abgerufenen Daten werden per HTTP POST an den in der Umgebungsvariable `URL` konfigurierten REST-API-Endpunkt übermittelt.  \r\n   - HTTP-Header können über die Umgebungsvariable `HEADER` angepasst werden.\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusinformationen, wie die Laufzeit der Abfrage und die Anzahl der übertragenen Datensätze, visuell dargestellt.\r\n\r\n### **Konfigurierbare Umgebungsvariablen**  \r\n\r\n| Variable       | Typ       | Standardwert                          | Beschreibung                                                  |\r\n|----------------|-----------|---------------------------------------|---------------------------------------------------------------|\r\n| `DEVICE_ID`    | String    | `1`                                   | ID des Geräts, dessen Daten abgefragt werden                  |\r\n| `TIMER`        | String    | `10`                                  | Zeitintervall für die Datenabfrage in Sekunden                |\r\n| `URL`          | String    | `\"http://url.com\"`           | Ziel-URL für den HTTP-POST-Request                            |\r\n| `HEADER`       | JSON      | `{}`                                  | Zusätzliche HTTP-Header (im JSON-Format)                      |\r\n\r\n### **Einsatzmöglichkeiten**  \r\n- **Automatische Datenübertragung:** Integration von Sensordaten aus InfluxDB in REST-basierte Systeme.  \r\n- **IoT-Datenpipelines:** Unterstützung von Echtzeit-Datenströmen in Cloud- und Edge-Anwendungen.  \r\n- **Datensynchronisation:** Regelmäßige Synchronisation von InfluxDB-Daten mit externen Datenplattformen.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "DEVICE_ID",
                "type": "num",
                "value": "1",
                "ui": {
                    "icon": "font-awesome/fa-microchip",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER",
                "type": "num",
                "value": "10",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "URL",
                "type": "str",
                "value": "http://192.168.0.84:4999",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "HEADER",
                "type": "json",
                "value": "{}",
                "ui": {
                    "icon": "font-awesome/fa-cloud-upload",
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "idpm-rest",
            "type": "idpm-rest",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "-",
            "keywords": "idpm, rest"
        },
        "color": "#3FADB5",
        "icon": "node-red/leveldb.svg",
        "status": {
            "x": 380,
            "y": 20,
            "wires": [
                {
                    "id": "16c9290388d72e82",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "f5c5556a9e4eb0ae",
        "type": "subflow",
        "name": "InfluxDB to FILE",
        "info": "### **Beschreibung**  \r\nDer **Influx to FILE**-Subflow ermöglicht das periodische Abrufen von Daten aus einer InfluxDB-Datenbank und deren Speicherung in einer lokalen Datei. Die Daten können in verschiedenen Formaten abgelegt werden, nämlich **JSON**, **CSV** oder **XML**. Dabei stehen flexible Konfigurationsoptionen zur Verfügung: Neben dem Ausgabemodus (Anhängen an bestehende Dateien oder Erstellen einer neuen Datei mit Zeitstempel) können auch Zielverzeichnis und Dateiname optional angegeben werden.\r\n\r\n### **Funktionsweise**  \r\n1. **Abfrageerstellung:**  \r\n   - Der Subflow generiert eine Flux-Query, um die letzten *n* Sekunden aus der InfluxDB abzufragen.  \r\n   - Der abzufragende Zeitraum wird über die Umgebungsvariable `TIMER` konfiguriert.  \r\n   - Die Query filtert die Daten anhand der `DEVICE_ID`, um gerätespezifische Informationen zu extrahieren.\r\n\r\n2. **Datenabruf:**  \r\n   - Die erstellte Flux-Query wird an die InfluxDB gesendet, und die abgerufenen Daten werden als JSON-Objekt weitergereicht.\r\n\r\n3. **Dateispeicherung:**  \r\n   - Die Daten werden im definierten Verzeichnis abgelegt, wobie ein konkreter Zielordner **optional** über `FOLDER` definiert werden kann.  \r\n   - Der Dateiname kann **optional** über `FILENAME` angegeben werden; fehlt dieser, wird ein Standardname samt Timestamp generiert.  \r\n   - Der Ausgabemodus wird über `FILE_MODE` bestimmt, wobei zwischen dem Anhängen an eine bestehende Datei (`append`) und dem Erstellen einer neuen Datei (`new`) gewählt werden kann.\r\n   - Über die Umgebungsvariable `FORMAT` kann das Ausgabeformat gewählt werden: **json**, **csv** oder **xml**.  \r\n\r\n4. **Statusanzeige:**  \r\n   - Während des Prozesses werden Statusmeldungen zur Laufzeitdauer und zur Anzahl der gespeicherten Datensätze ausgegeben.\r\n\r\n### **Konfigurierbare Umgebungsvariablen**\r\n\r\n| Variable       | Typ       | Standardwert | Beschreibung                                                  |\r\n|----------------|-----------|--------------|---------------------------------------------------------------|\r\n| `DEVICE_ID`    | Number    | `1`          | ID des Geräts, dessen Daten abgefragt werden                  |\r\n| `TIMER`  | Number    | `30`          | Zeitintervall für die Datenabfrage (in Sekunden)              |\r\n| `FOLDER`       | String    | -            | Optionaler Zielordner nach `/data/shared/`-Pfad |\r\n| `FILENAME`     | String    | -            | Optionaler Dateiname; wird bei Fehlen automatisch generiert   |\r\n| `FILE_MODE`    | String    | `append`     | Dateiausgabe-Modus: `append` (Anhängen) oder `new` (Neue Datei erstellen) |\r\n| `FORMAT`       | String    | `csv`        | Ausgabeformat: **csv**, **json** oder **xml**                   |\r\n\r\n### **Einsatzmöglichkeiten**  \r\n- **Speicherung von Zeitreihenmesswerten:** Archivierung von Sensordaten aus der InfluxDB in einem strukturierten Dateiformat.  \r\n- **Datenexport:** Erstellung von Exportdateien für externe Systeme oder weiterführende Analysen.  \r\n- **Regelmäßige Datensicherung:** Automatisierte Backups und Datenexporte zur kontinuierlichen Sicherung oder Auswertung von Zeitreihendaten.",
        "category": "IDPM-Data Forwarding",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "DEVICE_ID",
                "type": "num",
                "value": "1",
                "ui": {
                    "icon": "font-awesome/fa-microchip",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "TIMER",
                "type": "num",
                "value": "30",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "FOLDER",
                "type": "str",
                "value": "files",
                "ui": {
                    "icon": "font-awesome/fa-folder-open",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FILENAME",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-file-o",
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "FILE_MODE",
                "type": "str",
                "value": "append",
                "ui": {
                    "icon": "font-awesome/fa-plus-circle",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "Append"
                                },
                                "v": "append"
                            },
                            {
                                "l": {
                                    "de": "New"
                                },
                                "v": "new"
                            }
                        ]
                    }
                }
            },
            {
                "name": "FORMAT",
                "type": "str",
                "value": "csv",
                "ui": {
                    "icon": "font-awesome/fa-file-archive-o",
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "de": "CSV"
                                },
                                "v": "csv"
                            },
                            {
                                "l": {
                                    "de": "JSON"
                                },
                                "v": "json"
                            },
                            {
                                "l": {
                                    "de": "XML"
                                },
                                "v": "xml"
                            }
                        ]
                    }
                }
            }
        ],
        "meta": {
            "module": "idpm-file",
            "type": "idpm-file",
            "version": "0.0.1",
            "author": "IDPM",
            "desc": "-",
            "keywords": "ipdm, file"
        },
        "color": "#3FADB5",
        "icon": "node-red/file-out.svg",
        "status": {
            "x": 180,
            "y": 20,
            "wires": [
                {
                    "id": "71c0dcf56b57e3e9",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "41184f092bb6b065",
        "type": "subflow",
        "name": "Img-Cap-new",
        "info": "",
        "category": "IDPM-Data Forwarding",
        "in": [
            {
                "x": 80,
                "y": 80,
                "wires": [
                    {
                        "id": "cde49993d7949b9b"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 430,
                "y": 60,
                "wires": [
                    {
                        "id": "cde49993d7949b9b",
                        "port": 0
                    }
                ]
            },
            {
                "x": 450,
                "y": 120,
                "wires": [
                    {
                        "id": "cde49993d7949b9b",
                        "port": 1
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "PORT",
                "type": "num",
                "value": "8088"
            },
            {
                "name": "ID",
                "type": "num",
                "value": "1"
            }
        ],
        "meta": {
            "module": "Img-Cap-new"
        },
        "color": "#C0C0C0",
        "inputLabels": [
            "trigger"
        ],
        "outputLabels": [
            "Full message",
            "Image-String only"
        ],
        "icon": "font-awesome/fa-camera"
    },
    {
        "id": "699ee5c1c3dc383e",
        "type": "group",
        "z": "e7b0b0bc76ad7903",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "cb83d0b9bbc23ce4",
            "0dc25daa4866e6e4",
            "cf032448930f65c9",
            "333bf1e03b67b2ee"
        ],
        "x": 74,
        "y": 99,
        "w": 492,
        "h": 162
    },
    {
        "id": "2c4462b7cc4dfdcb",
        "type": "group",
        "z": "e129ee69a298a464",
        "name": "MIT GO-BACKEND!!!!",
        "style": {
            "label": true
        },
        "nodes": [
            "fa6f3b5f2b886fa5",
            "28638fc0bb27d4a8",
            "a2aecb780faf4789",
            "410fdab868a4fa58"
        ],
        "x": 74,
        "y": 159,
        "w": 632,
        "h": 122
    },
    {
        "id": "25c3fbbcd6db7a10",
        "type": "group",
        "z": "e129ee69a298a464",
        "name": "KOMPLETT in NODE-RED",
        "style": {
            "label": true
        },
        "nodes": [
            "9b40a920998c9150",
            "f7eb4cc988fb6c58",
            "bf7b2c9b78dc36d3"
        ],
        "x": 54,
        "y": 399,
        "w": 752,
        "h": 82
    },
    {
        "id": "d1d25278780d0bb3",
        "type": "global-config",
        "env": [
            {
                "name": "influx-token",
                "value": "secret-token",
                "type": "str"
            }
        ]
    },
    {
        "id": "e82a7202f23f3cdd",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "0b7c7515b1c6aa53",
        "type": "mqtt-broker",
        "name": "",
        "broker": "iot-gateway",
        "port": "${MQTT_LISTENER_LOCAL_TCP_ADDRESS}",
        "tls": "e82a7202f23f3cdd",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "3",
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a1403f82a270e6f4",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx-gateway",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "${INFLUXDB_URL}",
        "timeout": 10,
        "rejectUnauthorized": false
    },
    {
        "id": "e814f02eb2484f60",
        "type": "function",
        "z": "b784f457619f1095",
        "name": "collect & send data REST",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Versand mit Statusanzeige\n *\n * - Alle eingehenden Nachrichten werden als Datenpunkte in einem Buffer gespeichert.\n * - Nach Ablauf des konfigurierten Zeitintervalls (config.timerDelay oder msg.timerDelay) wird\n *   der Buffer per HTTP POST an den definierten Endpoint (config.endpoint oder msg.endpoint)\n *   versendet.\n * - Die HTTP-Header können ebenfalls per msg.headers überschrieben werden.\n * - Statusmeldungen werden ausschließlich über node.status() ausgegeben.\n */\n\n// Konfiguration\nvar config = {\n    topicSeparator: '/'\n};\n\n// Übernehmen der Konfiguration aus Umgebungsvariablen\nvar timerDelay = env.get(\"INTERVAL (sec)\") * 1000;\nvar endpoint   = env.get(\"URL\");\nvar headers    = env.get(\"HEADER\");\nvar topic      = env.get(\"TOPIC\");\n\n// ------------------------------\n// Hilfsfunktion zur Status-Aktualisierung (nur node.status)\n// ------------------------------\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n}\n\n// ==============================\n// Datenpunkt erfassen und in den Buffer einfügen\n// ==============================\nvar buffer = context.get('buffer') || [];\n\n// Extrahiere das letzte, nicht-leere Segment aus msg.topic als Datenpunkt-ID\nvar topicParts = msg.topic.split(config.topicSeparator).filter(function (part) {\n    return part !== '';\n});\nvar datapointId = topicParts[topicParts.length - 1];\n\n// Erstelle einen neuen Datenpunkt-Eintrag\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()  // ISO 8601 Zeitstempel\n};\n\n// Füge den Datenpunkt dem Buffer hinzu\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n\n// Status: Sammeln\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// ==============================\n// Timer-Logik: Versand des Buffers nach timerDelay, falls nicht bereits gesetzt\n// ==============================\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    setTimeout(function () {\n        // Status: Sende Daten...\n        updateStatus(\"Send Data ...\", \"yellow\", \"ring\");\n\n        // Lese den aktuell gespeicherten Buffer\n        var bufferToSend = context.get('buffer') || [];\n\n        // Erstelle den POST-Datenstring\n        var postData = JSON.stringify(bufferToSend);\n\n        // Zerlege den Endpoint in seine Bestandteile\n        var endpointUrl = url.parse(endpoint);\n        var options = {\n            hostname: endpointUrl.hostname,\n            port: endpointUrl.port,\n            path: endpointUrl.path,\n            method: 'POST',\n            headers: Object.assign({}, headers, {\n                'Content-Length': Buffer.byteLength(postData)\n            })\n        };\n\n        // Initialisiere den HTTP POST Request\n        var req = http.request(options, function (res) {\n            var responseBody = \"\";\n            res.setEncoding('utf8');\n            res.on('data', function (chunk) {\n                responseBody += chunk;\n            });\n            res.on('end', function () {\n                // node.log(\"HTTP POST response: \" + responseBody);\n                // Status: Versand abgeschlossen\n                updateStatus(\"Success Upload (\" + bufferToSend.length + \" Einträge)\", \"green\", \"dot\");\n            });\n        });\n\n        req.on('error', function (e) {\n            node.error(\"HTTP POST request error: \" + e.message);\n            updateStatus(\"Error sending data\", \"red\", \"ring\");\n        });\n\n        req.write(postData);\n        req.end();\n\n        // Buffer und Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n    }, timerDelay);\n}\n\n// Diese Funktion gibt keine reguläre Nachricht weiter.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 370,
        "y": 80,
        "wires": []
    },
    {
        "id": "b8ab04611540d0c6",
        "type": "mqtt in",
        "z": "b784f457619f1095",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "e814f02eb2484f60"
            ]
        ]
    },
    {
        "id": "fb4b6772875e2106",
        "type": "status",
        "z": "b784f457619f1095",
        "name": "",
        "scope": null,
        "x": 320,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "424f5da4789c7d8e",
        "type": "function",
        "z": "2a3d9e44553dfac0",
        "name": "collect & save in file",
        "func": "/**\n * Node-RED Function: Zeitbasierte Datenaggregation (Buffer) und Speicherung in einer Datei\n *\n * - Daten werden in einem Buffer gesammelt und nach einer bestimmten Zeit gespeichert.\n * - Speicherung in einer Datei als JSON, XML oder CSV.\n * - Möglichkeit, entweder eine Datei kontinuierlich zu erweitern oder eine neue Datei für jede Speicherung zu erstellen.\n */\n\n// -----------------------------------------------\n// 1) Subflow-Variablen aus Umgebungsvariablen\n// -----------------------------------------------\nvar config = {\n    topicSeparator: '/',\n    intervalMs: parseInt(env.get(\"INTERVAL (MS)\")) || 60000,   // Fallback: 60s\n    filePath: env.get(\"PATH\") || \"/data\",                         // Standardpfad\n    fileFormat: (env.get(\"FORMAT\") || \"json\").toLowerCase(),      // json, xml, csv\n    fileMode: (env.get(\"MODE\") || \"new\").toLowerCase(),           // \"append\" oder \"new\"\n    fileName: env.get(\"FILENAME\") || \"data\"                       // Basis-Dateiname für beide Modi\n};\n// node.log(\"Konfiguration geladen: \" + JSON.stringify(config));\n\n// -----------------------------------------------\n// 2) Hilfsfunktionen\n// -----------------------------------------------\n\nfunction formatTimestamp(date) {\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n/** Aktualisiert den Node-Status (ohne Subflow-Ausgang) */\nfunction updateStatus(statusMsg, fill, shape) {\n    node.status({ fill: fill, shape: shape, text: statusMsg });\n    // node.log(\"Status aktualisiert: \" + statusMsg);\n}\n\n/** Erzeugt den Dateiinhalt abhängig vom Format (JSON, XML oder CSV) */\nfunction buildFileContents(bufferToSave, format, existingContent = \"\") {\n    // node.log(\"Erstelle Dateiinhalt im Format \" + format + \" für \" + bufferToSave.length + \" Einträge.\");\n    switch (format) {\n        case \"xml\":\n            return buildXML(bufferToSave, existingContent);\n        case \"csv\":\n            return buildCSV(bufferToSave, existingContent);\n        case \"json\":\n        default:\n            return buildJSON(bufferToSave, existingContent);\n    }\n}\n\n/** Ermittelt die passende Dateiendung aus dem Format */\nfunction getFileExtension(format) {\n    switch (format) {\n        case \"xml\": return \"xml\";\n        case \"csv\": return \"csv\";\n        default: return \"json\";\n    }\n}\n\n/** JSON-Stringify mit optionaler Anfüge-Logik */\nfunction buildJSON(bufferToSave, existingContent) {\n    if (config.fileMode === \"append\" && existingContent) {\n        try {\n            let existingData = JSON.parse(existingContent);\n            if (Array.isArray(existingData)) {\n                existingData.push(...bufferToSave);\n            } else {\n                existingData = [...bufferToSave];\n            }\n            return JSON.stringify(existingData, null, 2);\n        } catch (err) {\n            node.error(\"JSON Parsing Error: \" + err.message);\n        }\n    }\n    return JSON.stringify(bufferToSave, null, 2);\n}\n\n/** CSV-Datei mit Header und Anfüge-Option */\nfunction buildCSV(bufferToSave, existingContent) {\n    const lines = existingContent ? existingContent.split(\"\\n\") : [\"DatapointId,Value,Timestamp\"];\n    bufferToSave.forEach(dp => {\n        // Ggf. weitere Escapes notwendig, wenn Kommas im Value\n        lines.push(`${dp.DatapointId},${dp.Value},${dp.Timestamp}`);\n    });\n    return lines.join(\"\\n\");\n}\n\n/** XML-Datei mit optionaler Anfüge-Logik */\nfunction buildXML(bufferToSave, existingContent) {\n    let xmlData = existingContent ? existingContent.replace(\"</data>\", \"\") : \"<data>\\n\";\n    bufferToSave.forEach(dp => {\n        xmlData += `  <datapoint>\\n`;\n        xmlData += `    <DatapointId>${dp.DatapointId}</DatapointId>\\n`;\n        xmlData += `    <Value>${dp.Value}</Value>\\n`;\n        xmlData += `    <Timestamp>${dp.Timestamp}</Timestamp>\\n`;\n        xmlData += `  </datapoint>\\n`;\n    });\n    xmlData += \"</data>\";\n    return xmlData;\n}\n\n// -----------------------------------------------\n// 3) Hauptlogik: Datensammlung und Timer\n// -----------------------------------------------\n\n// a) Bestehenden Buffer aus dem Context holen\nvar buffer = context.get('buffer') || [];\n// node.log(\"Buffer initialisiert. Aktueller Buffer-Inhalt: \" + JSON.stringify(buffer));\n\n// b) Datenpunkt erzeugen\nvar topicParts = msg.topic.split(config.topicSeparator).filter(part => part !== '');\nvar datapointId = topicParts[topicParts.length - 1] || \"unknown\";\n\nvar datapoint = {\n    DatapointId: datapointId,\n    Value: msg.payload,\n    Timestamp: new Date().toISOString()\n};\n// node.log(\"Neuer Datenpunkt erzeugt: \" + JSON.stringify(datapoint));\n\n// c) In den Buffer einfügen\nbuffer.push(datapoint);\ncontext.set('buffer', buffer);\n// node.log(\"Datenpunkt dem Buffer hinzugefügt. Buffer-Länge: \" + buffer.length);\n\n// d) Status aktualisieren\nupdateStatus(\"Collect (\" + buffer.length + \" items)\", \"blue\", \"dot\");\n\n// e) Timer-Logik: Daten nach config.intervalMs in Datei schreiben\nvar timerSet = context.get('timerSet') || false;\nif (!timerSet) {\n    context.set('timerSet', true);\n    // node.log(\"Timer gestartet für Intervall: \" + config.intervalMs + \" ms\");\n\n    setTimeout(function () {\n        // 1) Status: Speichern\n        updateStatus(\"Saving data ...\", \"yellow\", \"ring\");\n        // node.log(\"Timer ausgelöst. Starte Speicherung der Daten.\");\n\n        // 2) Buffer holen\n        var bufferToSave = context.get('buffer') || [];\n        // node.log(\"Anzahl der zu speichernden Einträge: \" + bufferToSave.length);\n\n        // 3) Dateiname & Pfad ermitteln\n        var ext = getFileExtension(config.fileFormat);\n        var fileName;\n\n        if (config.fileMode === \"append\") {\n            fileName = `${config.fileName}.${ext}`; // Feste Datei\n        } else {\n            var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            fileName = `${config.fileName}_${timestamp}.${ext}`; // Basisname + Zeitstempel\n        }\n        var fullPath = path.join(config.filePath, fileName);\n        // node.log(\"Ermittelter Dateiname: \" + fileName + \" im Verzeichnis: \" + config.filePath);\n\n        // 4) Verzeichnis erstellen, falls nicht vorhanden\n        try {\n            fs.mkdirSync(config.filePath, { recursive: true });\n            // node.log(\"Verzeichnis vorhanden oder erfolgreich erstellt: \" + config.filePath);\n        } catch (e) {\n            node.error(\"Verzeichnis konnte nicht erstellt werden: \" + e.message);\n            updateStatus(\"Dir error\", \"red\", \"ring\");\n            context.set('timerSet', false);\n            return;\n        }\n\n        // 5) Falls append-Modus, existierenden Inhalt lesen\n        let existingContent = \"\";\n        if (config.fileMode === \"append\" && fs.existsSync(fullPath)) {\n            try {\n                existingContent = fs.readFileSync(fullPath, 'utf8');\n                // node.log(\"Bestehenden Dateiinhalt erfolgreich gelesen.\");\n            } catch (err) {\n                node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n            }\n        }\n\n        // 6) Dateiinhalt erstellen\n        var fileContents = buildFileContents(bufferToSave, config.fileFormat, existingContent);\n        // node.log(\"Dateiinhalt erstellt.\");\n\n        // 7) Datei schreiben\n        fs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n            if (err) {\n                node.error(\"File write error: \" + err.message);\n                updateStatus(\"Saving error\", \"red\", \"ring\");\n            } else {\n                // node.log(\"Datei erfolgreich gespeichert: \" + fullPath);\n                updateStatus(\"Data saved (\" + bufferToSave.length + \" items)\", \"green\", \"dot\");\n            }\n        });\n\n        // 8) Buffer & Timer-Flag zurücksetzen\n        context.set('buffer', []);\n        context.set('timerSet', false);\n        // node.log(\"Buffer und Timer-Flag zurückgesetzt.\");\n\n    }, config.intervalMs);\n}\n\n// Keine reguläre Ausgabe\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 450,
        "y": 80,
        "wires": []
    },
    {
        "id": "e78f387d4ba01882",
        "type": "mqtt in",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "topic": "${TOPIC}",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "${BROKER}",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 80,
        "wires": [
            [
                "424f5da4789c7d8e"
            ]
        ]
    },
    {
        "id": "a101bcd063f6e0e4",
        "type": "status",
        "z": "2a3d9e44553dfac0",
        "name": "",
        "scope": null,
        "x": 360,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "7305073267fb70ed",
        "type": "status",
        "z": "dac356dc77e3d814",
        "name": "",
        "scope": [
            "bcee19f0a4e24893"
        ],
        "x": 420,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "bcee19f0a4e24893",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = env.get(\"OPC_ENDPOINT\")         || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = env.get(\"M_NODE_PARENT\")        || \"ns=3;s=Demo.Method\";\nconst methodId    = env.get(\"M_NODE_IMAGE\")         || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs  = env.get(\"M_ARGS\")               || \"\"\nconst checkNodeId = env.get(\"NODE_CHECK\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\")           || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = env.get(\"NODE_ACK_READ\")        || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = env.get(\"BASEPATH\")             || \"./data/images\";\nconst device      = env.get(\"DEVICE_ID\")            || \"local-1\";\nconst enableUpload= env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl   = env.get(\"UPLOAD_URL\");\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        savedFilePath = await saveImage(base64String, basePath, device);\n        node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders);\n            node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n    \n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // node.log(\"Using Headers: \" + JSON.stringify(mergedHeaders, null, 2));\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\nreturn main().then(\n    finalMsg => {\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n        return finalMsg;\n    },\n    err => {\n        node.error(err.message, msg);\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n        node.warn(\"[DEBUG] Caught error: \" + err.message);\n        return null;\n    }\n);\n// return main().then(\n//     finalMsg => finalMsg,\n//     err => null\n// );",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 410,
        "y": 200,
        "wires": [
            [
                "c7d47dd6e033c7ef"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "c7d47dd6e033c7ef",
        "type": "function",
        "z": "dac356dc77e3d814",
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 280,
        "wires": [
            [
                "f64651dd0ef28470"
            ]
        ]
    },
    {
        "id": "f64651dd0ef28470",
        "type": "http request",
        "z": "dac356dc77e3d814",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 550,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "da0584c47df5ed3d",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "OPC-Image-Capture-Process",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen\nconst endpoint    = env.get(\"OPC_ENDPOINT\")         || \"opc.tcp://192.168.0.84:48010\";\nconst objectId    = env.get(\"M_NODE_PARENT\")        || \"ns=3;s=Demo.Method\";\nconst methodId    = env.get(\"M_NODE_IMAGE\")         || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs  = env.get(\"M_ARGS\")               || \"\"\nconst checkNodeId = env.get(\"NODE_CHECK\")           || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"NODE_IMAGE\")           || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId   = env.get(\"NODE_ACK_READ\")        || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath    = env.get(\"BASEPATH\")             || \"./data/images\";\nconst device      = env.get(\"DEVICE_ID\")            || \"local-1\";\nconst enableUpload= env.get(\"ENABLE_UPLOAD\").toLowerCase();\nconst uploadUrl   = env.get(\"UPLOAD_URL\");\nconst additionalHeaders = typeof env.get(\"HEADERS\") === \"string\" ? JSON.parse(env.get(\"HEADERS\")) : env.get(\"HEADERS\") || { \"Content-Type\": \"application/octet-stream\" };\n\n// 2) Lese Security-spezifische Env Vars\nconst securityModeVar   = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username          = env.get(\"OPC_USER\");\nconst password          = env.get(\"OPC_PW\");\n// const certificateFile   = env.get(\"OPCUA_CERTFILE\")  || \"\";\n// const privateKeyFile    = env.get(\"OPCUA_KEYFILE\")   || \"\";\n\n// 3) Übersetze die Strings in node-opcua-Konstanten\nconst securityModes = {\n    \"NONE\": opcua.MessageSecurityMode.None,\n    \"SIGN\": opcua.MessageSecurityMode.Sign,\n    \"SIGNANDENCRYPT\": opcua.MessageSecurityMode.SignAndEncrypt\n};\nconst securityPolicies = {\n    \"NONE\": opcua.SecurityPolicy.None,\n    \"BASIC128RSA15\": opcua.SecurityPolicy.Basic128Rsa15,\n    \"BASIC256\": opcua.SecurityPolicy.Basic256,\n    \"BASIC256SHA256\": opcua.SecurityPolicy.Basic256Sha256\n};\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    let client, session, base64String, savedFilePath, errorOccurred = false;\n    try {\n        const clientName = \"node-red-opc-client_\" + new Date().toISOString().replace(/[:.]/g, \"-\");\n\n        // 4) OPC-UA Client erstellen, inkl. Security-Einstellungen\n        client = opcua.OPCUAClient.create({\n            applicationName: clientName,\n            endpointMustExist: false,\n            securityMode: securityModes[securityModeVar] || opcua.MessageSecurityMode.None,\n            securityPolicy: securityPolicies[securityPolicyVar] || opcua.SecurityPolicy.None,\n            connectionStrategy: {\n                initialDelay: 1000,\n                maxRetry: 30\n            }\n        });\n\n        // 5) OPC-UA-Server verbinden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Connecting...\" });\n        await client.connect(endpoint);\n\n        // 6) Session aufbauen:\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Create Session...\" });\n        let userIdentity = null;\n        if (username && password) {\n            userIdentity = { userName: username, password };\n        }\n        session = await client.createSession(userIdentity);\n\n        // 7) Methode aufrufen (z. B. Start Bildaufnahme)\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Call Method...\" });\n        // node.log(`[DEBUG] await method call`);\n        await callMethod(session, objectId, methodId);\n\n        // 8) Warten, bis checkNodeId = true\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Wait for boolean...\" });\n        await waitForBooleanTrue(session, checkNodeId, 20000);\n        // node.log(`[DEBUG] Wait till check node true...`);\n\n        // 9) Bild-String auslesen\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Reading image...\" });\n        base64String = await readImageString(session, imageNodeId);\n        // node.log(`[DEBUG] read image string`);\n\n        // 10) Lokales Speichern\n        node.status({ fill: \"blue\", shape: \"ring\", text: \"Saving file at\" + basePath });\n        // savedFilePath = await saveImage(base64String, basePath, device);\n        // node.log(`[DEBUG] Image saved at: ${savedFilePath}`);\n\n        // 11) Ack Node = true\n        node.status({ fill: \"green\", shape: \"ring\", text: \"Write Ack...\" });\n        // node.log(`[DEBUG] Writing ack node...`);\n        await writeBoolean(session, ackNodeId, true);\n        // node.log(`[DEBUG] wrote ack node`);\n\n        // 12) Optionaler Upload\n        if (enableUpload === \"true\" && uploadUrl) {\n            // node.log(`[DEBUG] trying to upload...`);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Uploading...\" });\n            await uploadFile(base64String, uploadUrl, additionalHeaders);\n            // node.log(\"[DEBUG] Upload done.\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Upload done\" });\n        } else {\n            node.warn(\"[DEBUG] No upload requested (enableUpload=false or missing URL).\");\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n        }\n\n        // 13) Disconnect from Server ans Ende verschoben\n\n        // 14) msg.payload für den Flow\n        msg.payload = {\n            success: true,\n            endpoint,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username: username || \"Anonymous\",\n            // savedFilePath,\n            // uploaded: (enableUpload === \"true\"),\n            image: base64String,\n            device_id: device,\n\n        };\n        return msg;\n\n    } catch (err) {\n        errorOccurred = true;\n        node.error(err.message, msg);\n        throw err;\n    } finally {\n        // Sicherstellen, dass die Session geschlossen wird\n        if (session) {\n            try {\n                await session.close();\n            } catch (closeErr) {\n                node.error(\"Fehler beim Schließen der Sitzung: \" + closeErr.message);\n            } finally {\n                session = null; // explizites Freigeben der Session-Referenz\n            }\n        }\n        // Sicherstellen, dass der Client getrennt wird\n        if (client) {\n            try {\n                await client.disconnect();\n            } catch (disconnectErr) {\n                node.error(\"Fehler beim Trennen der Verbindung: \" + disconnectErr.message);\n            }\n        }\n        // Node-Status final aktualisieren\n        if (errorOccurred) {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Error & Disconnected\" });\n        } else {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Done & Disconnected\" });\n        }\n    }\n}\n\n// ------------------------------------------------------\n// Hilfsfunktionen\n// ------------------------------------------------------\n\nasync function callMethod(session, objectId, methodId) {\n    const parsedArgs = typeof methodArgs === \"string\" ? JSON.parse(methodArgs) : methodArgs;\n    const inputArguments = Object.entries(parsedArgs).map(([key, value]) => ({\n        dataType: opcua.DataType.String, // Standard: String, falls nicht explizit angegeben\n        value: value\n    }));\n    \n    const methodToCall = {\n        objectId,\n        methodId,\n        inputArguments\n    };\n    const result = await session.call(methodToCall);\n    if (result.statusCode.name !== \"Good\") {\n        throw new Error(\"Method call failed: \" + result.statusCode.description);\n    }\n    // console.log(result);\n    return result;\n}\n\nasync function waitForBooleanTrue(session, nodeId, timeoutMs) {\n    const start = Date.now();\n    while (true) {\n        const dataValue = await session.readVariableValue(nodeId);\n        if (dataValue.statusCode.name === \"Good\" && dataValue.value.value === true) {\n            return;\n        }\n        if (Date.now() - start > timeoutMs) {\n            throw new Error(`Timeout: ${nodeId} did not become true within ${timeoutMs} ms`);\n        }\n        await delay(1000); // 1 Sekunde Pause\n    }\n}\n\nasync function readImageString(session, nodeId) {\n    const dataValue = await session.readVariableValue(nodeId);\n    if (dataValue.statusCode.name !== \"Good\") {\n        throw new Error(\"Cannot read image: \" + dataValue.statusCode.description);\n    }\n    return dataValue.value.value;\n}\n\nasync function saveImage(base64String, basePath, device) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const fileName = `${device}_${timestamp}.png`;\n    const fullPath = `${basePath}/${device}/${fileName}`;\n\n    await fs.ensureDir(`${basePath}/${device}`);\n\n    const buffer = Buffer.from(base64String, \"base64\");\n    await fs.writeFile(fullPath, buffer);\n\n    return fullPath;\n}\n\nasync function writeBoolean(session, nodeId, value) {\n    const opcuaDataType = opcua.DataType.Boolean;\n    const writeValue = {\n        nodeId,\n        attributeId: opcua.AttributeIds.Value,\n        value: {\n            value: {\n                dataType: opcuaDataType,\n                value\n            }\n        }\n    };\n    const statusCode = await session.write(writeValue);\n    if (statusCode.name !== \"Good\") {\n        throw new Error(\"Failed to write boolean: \" + statusCode.description);\n    }\n}\n\nasync function uploadFile(base64String, url, headers = {}) {\n    const fileData = base64String;\n    const parsedHeaders = typeof headers === \"string\" ? JSON.parse(headers) : headers;\n    \n    const defaultHeaders = {\n        \"Content-Type\": \"application/octet-stream\",\n    };\n    const mergedHeaders = { ...defaultHeaders, ...parsedHeaders };\n\n    // node.log(\"Using Headers: \" + JSON.stringify(mergedHeaders, null, 2));\n\n    let axiosConfig = { headers: mergedHeaders };\n\n    if (url.startsWith(\"https\")) {\n        axiosConfig.httpsAgent = new https.Agent({ rejectUnauthorized: false });\n    }\n\n    const response = await axios.post(url, fileData, axiosConfig);\n\n    if (response.status < 200 || response.status > 299) {\n        throw new Error(`Upload failed: HTTP ${response.status}`);\n    }\n    return response.data;\n}\n\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\n// return main().then(\n//     finalMsg => {\n//         node.status({ fill: \"green\", shape: \"dot\", text: \"Done\" });\n//         return finalMsg;\n//     },\n//     err => {\n//         node.error(err.message, msg);\n//         node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n//         node.warn(\"[DEBUG] Caught error: \" + err.message);\n//         return null;\n//     }\n// );\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 530,
        "y": 20,
        "wires": [
            [
                "7a91daf2877a46a5"
            ]
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "0b0d19296544b9f8",
        "type": "status",
        "z": "a83312e9e2e175ac",
        "name": "",
        "scope": null,
        "x": 80,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "18c462c840ed1a77",
        "type": "http request",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://iot-gateway:8088/api/save-image",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1130,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "7a91daf2877a46a5",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "d": true,
        "name": "toBase64",
        "func": "// Extrahiere den Dateinamen aus dem savedFilePath\nconst fileName = msg.savedFilePath || msg.payload.savedFilePath; \n// const fileName = filePath.split(\"/\").pop(); // Letzter Abschnitt nach dem \"/\"\n\n// Konvertiere das Bild in Base64\nmsg.payload.device = msg.payload.device_id;\nmsg.payload.image = msg.payload.image.toString(\"base64\");\n\n// Übergabe des Dateinamens\nmsg.fileName = fileName;\nmsg.url = env.get(\"GATEWAY_UPLOAD_URL\");\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 20,
        "wires": [
            [
                "18c462c840ed1a77"
            ]
        ]
    },
    {
        "id": "92f6fd0436ca3513",
        "type": "function",
        "z": "a83312e9e2e175ac",
        "name": "OPC-Image-Capture-Process via GO Backend",
        "func": "// ------------------------------------------------------\n// \"Image Capture Process via Go Backend\"\n// ------------------------------------------------------\n\n// 1) Lese generelle Variablen aus der Umgebung\nconst endpoint = env.get(\"OPC Endpoint\") || \"opc.tcp://192.168.0.84:48010\";\nconst objectId = env.get(\"Object ID\") || \"ns=3;s=Demo.Method\";\nconst methodId = env.get(\"Method ID\") || \"ns=3;s=Demo.Method.DoSomethingAfter10s\";\nconst methodArgs = env.get(\"Method Args\") || \"{}\";\nconst checkNodeId = env.get(\"Check Node ID\") || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst imageNodeId = env.get(\"Image Node ID\") || \"ns=3;s=Demo.Dynamic.Scalar.ImageGIF\";\nconst ackNodeId = env.get(\"Acknowledge Node ID\") || \"ns=3;s=Demo.Dynamic.Scalar.Boolean\";\nconst basePath = \"\";\nconst deviceId = env.get(\"Device ID\");\nconst enableUpload = \"true\"; // env.get(\"Upload\").toLowerCase();\nconst uploadUrl = env.get(\"Upload URL\");\n\nconst additionalHeaders = typeof env.get(\"Header\") === \"string\" ? JSON.parse(env.get(\"Header\")) : env.get(\"Header\") || { \"Content-Type\": \"application/json\" };\n\n// 2) Lese Security-Parameter aus der Umgebung\nconst securityModeVar = String(env.get(\"OPC_SEC_MODE\") || \"NONE\").toUpperCase();\nconst securityPolicyVar = String(env.get(\"OPC_SEC_POLICY\") || \"NONE\").toUpperCase();\nconst username = env.get(\"OPC_USER\") || \"\";\nconst password = env.get(\"OPC_PW\") || \"\";\n\n// 3) Backend-URL für die Verarbeitung\nnode.log(env.get(\"WEBUI_HTTP_PORT\"));\nconst port = env.get(\"WEBUI_HTTP_PORT\") || \"8088\";\nconst backendUrl = `http://iot-gateway:${port}/api/img-process`;\n\n// Node-RED UI Feedback\nnode.status({ fill: \"grey\", shape: \"dot\", text: \"Init...\" });\n\n// ------------------------------------------------------\n// Hauptfunktion (asynchron)\n// ------------------------------------------------------\nasync function main() {\n    try {\n        // 4) Payload für das Go-Backend vorbereiten\n        const payload = {\n            endpoint,\n            objectId,\n            methodId,\n            methodArgs,\n            checkNodeId,\n            imageNodeId,\n            ackNodeId,\n            basePath,\n            deviceId,\n            enableUpload,\n            uploadUrl,\n            securityMode: securityModeVar,\n            securityPolicy: securityPolicyVar,\n            username,\n            password,\n            headers: additionalHeaders\n        };\n\n        node.log(payload);\n\n        // 5) Anfrage an das Go-Backend senden\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sending request...\" });\n        const response = await axios.post(backendUrl, payload, { headers: additionalHeaders });\n        node.log(\"Request sent.\")\n\n        // 6) Überprüfe die Antwort des Go-Backends\n        if (response.status !== 200 || !response.data.success) {\n            throw new Error(`Backend error: ${response.data.error || \"Unknown error\"}`);\n        }\n\n        // 7) Erfolgreiche Verarbeitung\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Capture done\" });\n\n        msg.payload = {\n            success: true,\n            endpoint: response.data.endpoint,\n            securityMode: response.data.securityMode,\n            securityPolicy: response.data.securityPolicy,\n            username: response.data.username,\n            image: response.data.image,\n            device_id: response.data.device_id,\n            uploaded: response.data.uploaded || false\n        };\n\n        return msg;\n    } catch (err) {\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n        node.error(err.message, msg);\n        throw err;\n    }\n}\n\n// ------------------------------------------------------\n// Am Ende: main() aufrufen (asynchron) und Promise zurückgeben\n// ------------------------------------------------------\nreturn main().then(\n    finalMsg => finalMsg,\n    err => null\n);\n",
        "outputs": 1,
        "timeout": "30",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "opcua",
                "module": "node-opcua"
            },
            {
                "var": "axios",
                "module": "axios"
            },
            {
                "var": "fs",
                "module": "fs-extra"
            },
            {
                "var": "https",
                "module": "https"
            }
        ],
        "x": 540,
        "y": 100,
        "wires": [
            []
        ],
        "info": "# Image Capture Process (OPC UA)\r\n\r\nDiese Funktion stellt eine Verbindung zu einem OPC UA Server her, um einen „Image Capture“-Prozess anzustoßen und auszuführen. Sie erledigt folgende Schritte:\r\n\r\n## 1. OPC-UA-Client erzeugen und verbinden\r\n\r\nVerbindet sich mit dem Endpoint (z. B. `opc.tcp://localhost:48010`)\r\nUnterstützt optional Security Mode / Policy (z. B. None, Sign, SignAndEncrypt)\r\nOptionaler Benutzername/Passwort, sonst Anonymous\r\n## 2. OPC-UA-Methode aufrufen\r\n\r\nLiest die Node-IDs aus `msg` (oder Environment Variables) aus (z. B. `methodId`, `objectId`)\r\nStartet damit den Bildaufnahme-Prozess am Server\r\n## 3. Warten auf Boolean (Check Node)\r\n\r\nDie Funktion wartet bis ein bestimmtes OPC-UA-Node (z. B. `ns=3;s=Demo.Dynamic.Scalar.Boolean`) auf `true` wechselt\r\nTimeout nach 20 Sekunden\r\n## 4. Bild-Daten (String) lesen\r\n\r\nLiest den Bild-String (Base64 oder ASCII) aus einer OPC UA-Variable (`imageNodeId`)\r\n## 5. Bild lokal speichern\r\n\r\nErzeugt einen Timestamp-basierten Dateinamen im angegebenen `basePath`/\\device`-Ordner (z. B. `C:/.../local-1/...png`)\r\nVerwendet `fs-extra` (ensureDir, writeFile)\r\n## 6. ACK-Flag schreiben\r\n\r\nSchreibt `true` in eine andere Node-ID (`ackNodeId`) als Bestätigung, dass das Bild erfolgreich abgeholt wurde\r\n## 7. (Optional) Upload\r\n\r\nWenn `enableUpload` = „true“ und `uploadUrl` nicht leer sind, lädt die Funktion das gespeicherte Bild als Binärdaten via HTTP POST hoch\r\nRückgabe (msg.payload)\r\n\r\n - `msg.payload.success = true`\r\n - `msg.payload.savedFilePath` zeigt den Speicherort\r\n - `msg.payload.uploaded` = true/false je nach Upload\r\n - Eingangs-Parameter (in msg)\r\n - `msg.endpoint`: OPC UA Endpoint (z. B. \"opc.tcp://localhost:48010\")\r\n - `msg.methodId`, `msg.objectId`: IDs der aufzurufenden OPC UA-Methode\r\n - `msg.checkNodeId`: Node-Id (Boolean), auf die gewartet wird\r\n - `msg.imageNodeId`: Node-Id mit dem Bild-String\r\n - `msg.ackNodeId`: Node-Id, in die `true` geschrieben wird\r\n - `msg.basePath`: Basis-Pfad zum Speichern\r\n - `msg.device`: Geräte-/Unterordner-Name\r\n - `msg.enableUpload`: \"true\"/\"false\", ob hochgeladen werden soll\r\n - `msg.uploadUrl`: Ziel-URL für den Upload\r\n - `msg.securityModeVar`, `msg.securityPolicyVar`: (Optional) Security-Einstellungen\r\n - `msg.username`, `msg.password`: (Optional) Anmeldedaten für OPC UA\r\nFalls im msg etwas nicht belegt ist, greift die Funktion auf Subflow-Umgebungsvariablen oder Default-Werte zurück.\r\n\r\nAchtung: Damit die Funktion läuft, müssen die benötigten Module (node-opcua, fs-extra, axios) entweder im Global Context (settings.js) oder als External Modules in den Function Node-Einstellungen eingebunden sein."
    },
    {
        "id": "8b0261fb901db5f1",
        "type": "influxdb in",
        "z": "ef4290a715908540",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 500,
        "y": 160,
        "wires": [
            [
                "92542095e6a14c91"
            ]
        ]
    },
    {
        "id": "498350a0e7d7fa21",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER\"); // Erwartet einen numerischen Wert in Sekunden\n\nmsg.startTime = process.hrtime();\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 60; // Standard: 1 Minute (60 Sekunden)\n}\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 330,
        "y": 160,
        "wires": [
            [
                "8b0261fb901db5f1"
            ]
        ]
    },
    {
        "id": "92542095e6a14c91",
        "type": "function",
        "z": "ef4290a715908540",
        "name": "http send",
        "func": "/**\n * Node-RED Function: Datenversand (Send) - für InfluxDB-Daten\n *\n * - Nimmt die von InfluxDB gelieferten Daten in msg.payload entgegen.\n * - Versendet diese per HTTP POST an den konfigurierten Endpoint.\n * - HTTP-Header und Endpoint können über Umgebungsvariablen (env) oder msg überschrieben werden.\n * - Aktualisiert ausschließlich den Status (node.status).\n */\n\n// Konfiguration: Werte aus env oder msg übernehmen\nvar endpoint = env.get(\"URL\") || msg.endpoint;\nvar headers  = env.get(\"HEADER\") || msg.headers;\n\n// Prüfe, ob die Startzeit vorhanden ist\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    return null;\n}\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n\n// Überprüfe, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Kein Data zu senden\" });\n    return null;\n}\n\n// Status: Transformiere Daten...\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Transform Data ...\" });\n\nif (Array.isArray(msg.payload)) {\n    msg.payload = msg.payload.map(entry => {\n        return {\n            \"DatapointID\": entry.datapointId,   // Ursprünglich \"datapointId\"\n            \"Value\": entry._value,              // Ursprünglich \"_value\"\n            \"Timestamp\": formatTimestamp(entry._time)  // Formatierter Timestamp\n        };\n    });\n} else {\n    // Fallback für den Fall, dass msg.payload ein einzelnes Objekt ist\n    msg.payload = {\n        \"DatapointID\": msg.payload.datapointId,\n        \"Value\": msg.payload._value,\n        \"Timestamp\": formatTimestamp(msg.payload._time)\n    };\n}\n\n// Status: Sende Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Send Data ...\" });\n\n// Erstelle den POST-Datenstring (JSON) aus msg.payload\nvar postData = JSON.stringify(msg.payload);\n\n// Zerlege den Endpoint in seine Bestandteile\nvar endpointUrl = url.parse(endpoint);\nvar options = {\n    hostname: endpointUrl.hostname,\n    port: endpointUrl.port,\n    path: endpointUrl.path,\n    method: 'POST',\n    headers: Object.assign({}, headers, {\n        'Content-Length': Buffer.byteLength(postData),\n        'Content-Type': 'application/json'\n    })\n};\n\n// Initialisiere den HTTP POST Request\nvar req = http.request(options, function (res) {\n    var responseBody = \"\";\n    res.setEncoding('utf8');\n    res.on('data', function (chunk) {\n        responseBody += chunk;\n    });\n    res.on('end', function () {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            // text: `${entryCount} Einträge, Dauer: ${durationMs.toFixed(2)} ms, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n            text: `${entryCount} Einträge, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n        });\n        // node.status({ fill: \"green\", shape: \"dot\", text: \"Daten versendet (\" + entryCount + \" Einträge), Dauer: ${durationMs.toFixed(2)} ms\" });\n    });\n});\n\nreq.on('error', function (e) {\n    node.error(\"HTTP POST request error: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Versand fehlgeschlagen\" });\n});\n\n// Sende den POST-Datenstring\nreq.write(postData);\nreq.end();\n\n// Es wird keine Nachricht weitergereicht.\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 660,
        "y": 160,
        "wires": []
    },
    {
        "id": "16c9290388d72e82",
        "type": "status",
        "z": "ef4290a715908540",
        "name": "",
        "scope": null,
        "x": 260,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "9face9eff42b06e3",
        "type": "inject",
        "z": "ef4290a715908540",
        "name": "",
        "props": [],
        "repeat": "${TIMER}",
        "crontab": "",
        "once": true,
        "onceDelay": "${TIMER}",
        "topic": "",
        "x": 120,
        "y": 160,
        "wires": [
            [
                "498350a0e7d7fa21"
            ]
        ]
    },
    {
        "id": "fa7abbee5d7c7eb7",
        "type": "influxdb in",
        "z": "f5c5556a9e4eb0ae",
        "influxdb": "a1403f82a270e6f4",
        "name": "test-influx",
        "query": "",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "idpm",
        "x": 500,
        "y": 180,
        "wires": [
            [
                "a2fa737c0195922b"
            ]
        ]
    },
    {
        "id": "4a16a8db342b7323",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "build query",
        "func": "var deviceId = msg.deviceID || env.get(\"DEVICE_ID\");\nvar timer = msg.timer || env.get(\"TIMER\"); // Erwartet einen numerischen Wert in Sekunden\n\n// Fallback, falls timer nicht definiert ist\nif (!timer) {\n    timer = 60; // Standard: 1 min\n}\n\n// Erfassen des Startzeitpunktes\nmsg.startTime = process.hrtime();\n\n// Erstelle eine relative Zeitangabe im Flux-Format\nvar durationStr = \"-\" + timer + \"s\";\n\n// Aufbau des Flux-Queries: Daten vom aktuellen Zeitpunkt zurück bis zum angegebenen Zeitraum\nmsg.query = `\nfrom(bucket: \"iot-data\")\n  |> range(start: ${durationStr}, stop: now())\n  |> filter(fn: (r) => r[\"deviceId\"] == \"${deviceId}\")\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 330,
        "y": 180,
        "wires": [
            [
                "fa7abbee5d7c7eb7"
            ]
        ]
    },
    {
        "id": "a2fa737c0195922b",
        "type": "function",
        "z": "f5c5556a9e4eb0ae",
        "name": "influx-to-file",
        "func": "/**\n * Node-RED Function: Speichert die empfangenen Daten in eine Datei.\n *\n * - Unterstützt verschiedene Formate (JSON, CSV, XML).\n * - Kann entweder an eine Datei anhängen oder eine neue Datei mit Timestamp erstellen.\n * - Erstellt automatisch das Verzeichnis, falls es nicht existiert.\n * - Aktualisiert den Node-Status entsprechend.\n */\n\nif (!msg.startTime) {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Fehler: Keine Startzeit!\" });\n    return null;\n}\n\n// Endzeit erfassen und Dauer berechnen\nconst endTime = process.hrtime(msg.startTime);\nconst durationMs = (endTime[0] * 1000) + (endTime[1] / 1e6); // Umwandlung in Millisekunden\n\n// Konfiguration aus Umgebungsvariablen oder msg übernehmen\nvar filePath = env.get(\"FOLDER\") || msg.filePath || \"/files\";  // Standardverzeichnis\nvar fileName = env.get(\"FILENAME\") || msg.fileName || \"influx_data\"; // Basis-Dateiname\nvar fileMode = env.get(\"FILE_MODE\") || msg.fileMode || \"append\"; // \"append\" oder \"new\"\nvar fileFormat = (env.get(\"FORMAT\") || msg.fileFormat || \"json\").toLowerCase(); // \"json\", \"csv\", \"xml\"\n\n// Überprüfen, ob msg.payload Daten enthält\nif (!msg.payload || (Array.isArray(msg.payload) && msg.payload.length === 0)) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Keine Daten zu speichern\" });\n    return null;\n}\n\n// Status: Speichern der Daten...\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Speichere Daten...\" });\n\n// Funktion zur Umwandlung des Zeitformats\nfunction formatTimestamp(isoString) {\n    let date = new Date(isoString);\n    const pad = (num, size = 2) => ('000' + num).slice(-size);\n    return `${pad(date.getDate())}.${pad(date.getMonth() + 1)}.${date.getFullYear()} ` +\n        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad(date.getMilliseconds(), 3)}`;\n}\n\n// Funktion zur Umwandlung der Daten in das gewünschte Format\nfunction convertData(data, format, existingContent = \"\") {\n    // Umwandlung der Datenstruktur\n    let transformedData = data.map(item => ({\n        DatapointId: item.datapointId,\n        Value: item._value,\n        Timestamp: formatTimestamp(item._time)\n    }));\n\n    if (format === \"json\") {\n        if (fileMode === \"append\" && existingContent) {\n            try {\n                let existingData = JSON.parse(existingContent);\n                if (Array.isArray(existingData)) {\n                    existingData.push(...transformedData);\n                } else {\n                    existingData = [...transformedData];\n                }\n                return JSON.stringify(existingData, null, 2);\n            } catch (err) {\n                node.error(\"JSON Parsing Error: \" + err.message);\n            }\n        }\n        return JSON.stringify(transformedData, null, 2);\n    }\n    if (format === \"csv\") {\n        let keys = [\"DatapointId\", \"Value\", \"Timestamp\"];\n        let csvRows = transformedData.map(row => keys.map(k => row[k]).join(\",\"));\n        if (fileMode === \"append\" && existingContent) {\n            return existingContent + \"\\n\" + csvRows.join(\"\\n\");\n        }\n        return keys.join(\",\") + \"\\n\" + csvRows.join(\"\\n\");\n    }\n    if (format === \"xml\") {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<data>\\n';\n        transformedData.forEach(item => {\n            xml += \"  <entry>\\n\";\n            xml += `    <DatapointId>${item.DatapointId}</DatapointId>\\n`;\n            xml += `    <Value>${item.Value}</Value>\\n`;\n            xml += `    <Timestamp>${item.Timestamp}</Timestamp>\\n`;\n            xml += \"  </entry>\\n\";\n        });\n        xml += \"</data>\";\n        return xml;\n    }\n    return JSON.stringify(transformedData, null, 2); // Fallback: JSON\n}\n\n\n// Dateiname & Pfad ermitteln\nvar fileExtension = fileFormat === \"xml\" ? \"xml\" : fileFormat === \"csv\" ? \"csv\" : \"json\";\nvar finalFileName = fileMode === \"new\"\n    ? `${fileName}_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExtension}`\n    : `${fileName}.${fileExtension}`;\nvar folderPath = path.join(\"/data/shared/\", filePath);\nvar fullPath = path.join(folderPath, finalFileName);\nnode.log(fullPath);\n\n// Falls nötig, Verzeichnis erstellen\ntry {\n    fs.mkdirSync(folderPath, { recursive: true });\n} catch (e) {\n    node.error(\"Fehler beim Erstellen des Verzeichnisses: \" + e.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Verzeichnisfehler\" });\n    return null;\n}\n\n// Falls append-Modus, existierenden Inhalt lesen\nlet existingContent = \"\";\nif (fileMode === \"append\" && fs.existsSync(fullPath)) {\n    try {\n        existingContent = fs.readFileSync(fullPath, 'utf8');\n    } catch (err) {\n        node.error(\"Fehler beim Lesen der Datei: \" + err.message);\n    }\n}\n\n// Dateiinhalt generieren\nvar fileContents = convertData(msg.payload, fileFormat, existingContent);\n\n// Datei schreiben\nfs.writeFile(fullPath, fileContents, 'utf8', function (err) {\n    if (err) {\n        node.error(\"Fehler beim Speichern der Datei: \" + err.message);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Speichern fehlgeschlagen\" });\n    } else {\n        var entryCount = Array.isArray(msg.payload) ? msg.payload.length : 1;\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: `${entryCount} Einträge, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n            // text: `Gespeichert (${entryCount} Einträge), Dauer: ${durationMs.toFixed(2)} ms, Timestamp: ${formatTimestamp(new Date().toISOString())}`\n        });\n\n        // Ausgabe der Zeitmessung für Debugging\n        node.log(`Datei gespeichert in ${durationMs.toFixed(2)} ms: ${fullPath}`);\n    }\n});\n\n// Keine Weitergabe der Nachricht\nreturn null;\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 670,
        "y": 180,
        "wires": []
    },
    {
        "id": "71c0dcf56b57e3e9",
        "type": "status",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "scope": null,
        "x": 60,
        "y": 20,
        "wires": [
            []
        ]
    },
    {
        "id": "1f74a5f312e69b31",
        "type": "inject",
        "z": "f5c5556a9e4eb0ae",
        "name": "",
        "props": [],
        "repeat": "${TIMER}",
        "crontab": "",
        "once": true,
        "onceDelay": "${TIMER}",
        "topic": "",
        "x": 150,
        "y": 180,
        "wires": [
            [
                "4a16a8db342b7323"
            ]
        ]
    },
    {
        "id": "cde49993d7949b9b",
        "type": "function",
        "z": "41184f092bb6b065",
        "name": "function 1",
        "func": "const url = `http://iot-gateway:${env.get('PORT')}/api/image-capture-processes/${env.get('ID')}/trigger`;\n\nconst options = {\n    method: 'POST'\n};\n\nconst req = http.request(url, options, (res) => {\n    let buffer = '';\n\n    res.on('data', (chunk) => {\n        buffer += chunk.toString('utf8');\n    });\n\n    res.on('end', () => {\n        node.send([null, { payload: buffer }]);\n    });\n});\n\nreq.on('error', (e) => {\n    node.send([{ payload: e.message }, null]);\n});\n\nreq.write(JSON.stringify(msg.payload));\nreq.end();\n\nreturn null; // Wichtig, da der Code asynchron ist",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "http",
                "module": "http"
            }
        ],
        "x": 200,
        "y": 80,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "ae2a9d9015479641",
        "type": "subflow:ef4290a715908540",
        "z": "4071c101bbc3e907",
        "d": true,
        "name": "",
        "env": [
            {
                "name": "URL",
                "value": "http://192.168.0.84:4999//data/readingsarray",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 140,
        "wires": []
    },
    {
        "id": "2ec19ab9400b415f",
        "type": "subflow:f5c5556a9e4eb0ae",
        "z": "4071c101bbc3e907",
        "name": "",
        "env": [
            {
                "name": "DEVICE_ID",
                "value": "2",
                "type": "num"
            },
            {
                "name": "TIMER",
                "value": "10",
                "type": "num"
            },
            {
                "name": "FILENAME",
                "value": "test1",
                "type": "str"
            },
            {
                "name": "FORMAT",
                "value": "json",
                "type": "str"
            }
        ],
        "x": 120,
        "y": 260,
        "wires": []
    },
    {
        "id": "fa6f3b5f2b886fa5",
        "type": "inject",
        "z": "e129ee69a298a464",
        "g": "2c4462b7cc4dfdcb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 220,
        "wires": [
            [
                "410fdab868a4fa58"
            ]
        ]
    },
    {
        "id": "28638fc0bb27d4a8",
        "type": "debug",
        "z": "e129ee69a298a464",
        "g": "2c4462b7cc4dfdcb",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 200,
        "wires": []
    },
    {
        "id": "a2aecb780faf4789",
        "type": "image",
        "z": "e129ee69a298a464",
        "g": "2c4462b7cc4dfdcb",
        "name": "",
        "width": 160,
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 580,
        "y": 240,
        "wires": []
    },
    {
        "id": "410fdab868a4fa58",
        "type": "subflow:41184f092bb6b065",
        "z": "e129ee69a298a464",
        "g": "2c4462b7cc4dfdcb",
        "name": "Img-Cap-new",
        "x": 370,
        "y": 220,
        "wires": [
            [
                "28638fc0bb27d4a8"
            ],
            [
                "a2aecb780faf4789"
            ]
        ]
    },
    {
        "id": "f7eb4cc988fb6c58",
        "type": "subflow:dac356dc77e3d814",
        "z": "e129ee69a298a464",
        "g": "25c3fbbcd6db7a10",
        "name": "opc.tcp://192.168.0.166:48012",
        "env": [
            {
                "name": "OPC_ENDPOINT",
                "value": "opc.tcp://192.168.0.166:48012",
                "type": "str"
            },
            {
                "name": "M_NODE_PARENT",
                "value": "ns=3;s=Demo.Method",
                "type": "str"
            },
            {
                "name": "M_NODE_IMAGE",
                "value": "ns=3;s=Demo.Method.Multiply",
                "type": "str"
            },
            {
                "name": "UPLOAD_URL",
                "value": "http://localhost:1880/opc-upload",
                "type": "str"
            },
            {
                "name": "HEADERS",
                "value": "{}",
                "type": "json"
            }
        ],
        "x": 450,
        "y": 440,
        "wires": [
            [
                "bf7b2c9b78dc36d3"
            ]
        ]
    },
    {
        "id": "9b40a920998c9150",
        "type": "inject",
        "z": "e129ee69a298a464",
        "g": "25c3fbbcd6db7a10",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 440,
        "wires": [
            [
                "f7eb4cc988fb6c58"
            ]
        ]
    },
    {
        "id": "bf7b2c9b78dc36d3",
        "type": "image",
        "z": "e129ee69a298a464",
        "g": "25c3fbbcd6db7a10",
        "name": "",
        "width": 160,
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 680,
        "y": 440,
        "wires": []
    },
    {
        "id": "cb83d0b9bbc23ce4",
        "type": "http in",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP POST /opc-upload",
        "url": "/opc-upload",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 220,
        "wires": [
            [
                "333bf1e03b67b2ee",
                "0dc25daa4866e6e4"
            ]
        ]
    },
    {
        "id": "0dc25daa4866e6e4",
        "type": "http response",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "HTTP Response",
        "statusCode": "200",
        "headers": {},
        "x": 460,
        "y": 220,
        "wires": []
    },
    {
        "id": "cf032448930f65c9",
        "type": "comment",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "Test Upload",
        "info": "",
        "x": 210,
        "y": 140,
        "wires": []
    },
    {
        "id": "333bf1e03b67b2ee",
        "type": "debug",
        "z": "e7b0b0bc76ad7903",
        "g": "699ee5c1c3dc383e",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "f2a367057c5f98d6",
        "type": "subflow:a83312e9e2e175ac",
        "z": "10b23f05464fa924",
        "name": "Img-Cap-Process-2",
        "x": 410,
        "y": 120,
        "wires": [
            [
                "ef2d2c093d3c50ec"
            ]
        ]
    },
    {
        "id": "ef2d2c093d3c50ec",
        "type": "image",
        "z": "10b23f05464fa924",
        "name": "",
        "width": "200",
        "data": "payload.image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 640,
        "y": 120,
        "wires": []
    },
    {
        "id": "c3e0b2fcb2e5fbe2",
        "type": "inject",
        "z": "10b23f05464fa924",
        "name": "Trigger",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 120,
        "wires": [
            [
                "f2a367057c5f98d6"
            ]
        ]
    }
]